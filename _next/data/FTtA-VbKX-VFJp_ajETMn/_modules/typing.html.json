{"pageProps":{"state":{"globalHeaders":{"https://napari-hub.org":{"level":1,"children":[],"href":"https://napari-hub.org","text":"napari hub"},"https://github.com/napari/napari":{"level":1,"children":[],"href":"https://github.com/napari/napari","text":"napari source code"},"/roadmaps/index.html":{"level":1,"children":["/roadmaps/0_4.html","/roadmaps/0_3_retrospective.html","/roadmaps/0_3.html"],"href":"/roadmaps/index.html","text":"Roadmaps"},"/roadmaps/0_3.html":{"level":2,"children":[],"href":"/roadmaps/0_3.html","text":"Roadmap 0.3"},"/roadmaps/0_3_retrospective.html":{"level":2,"children":[],"href":"/roadmaps/0_3_retrospective.html","text":"Roadmap 0.3 Retrospective"},"/roadmaps/0_4.html":{"level":2,"children":[],"href":"/roadmaps/0_4.html","text":"Roadmap 0.4"},"/release/index.html":{"level":1,"children":["/release/release_0_4_12.html","/release/release_0_4_11.html","/release/release_0_4_10.html","/release/release_0_4_9.html","/release/release_0_4_8.html","/release/release_0_4_7.html","/release/release_0_4_6.html","/release/release_0_4_5.html","/release/release_0_4_4.html","/release/release_0_4_3.html","/release/release_0_4_2.html","/release/release_0_4_1.html","/release/release_0_4_0.html","/release/release_0_3_8.html","/release/release_0_3_7.html","/release/release_0_3_6.html","/release/release_0_3_5.html","/release/release_0_3_4.html","/release/release_0_3_3.html","/release/release_0_3_2.html","/release/release_0_3_1.html","/release/release_0_3_0.html","/release/release_0_2_12.html","/release/release_0_2_11.html","/release/release_0_2_10.html","/release/release_0_2_9.html","/release/release_0_2_8.html","/release/release_0_2_7.html","/release/release_0_2_6.html","/release/release_0_2_5.html","/release/release_0_2_4.html","/release/release_0_2_3.html","/release/release_0_2_1.html","/release/release_0_2_0.html","/release/release_0_1_5.html","/release/release_0_1_3.html","/release/release_0_1_0.html"],"href":"/release/index.html","text":"Release notes"},"/release/release_0_1_0.html":{"level":2,"children":[],"href":"/release/release_0_1_0.html","text":"napari 0.1.0"},"/release/release_0_1_3.html":{"level":2,"children":[],"href":"/release/release_0_1_3.html","text":"napari 0.1.3"},"/release/release_0_1_5.html":{"level":2,"children":[],"href":"/release/release_0_1_5.html","text":"napari 0.1.5"},"/release/release_0_2_0.html":{"level":2,"children":[],"href":"/release/release_0_2_0.html","text":"napari 0.2.0"},"/release/release_0_2_1.html":{"level":2,"children":[],"href":"/release/release_0_2_1.html","text":"napari 0.2.1"},"/release/release_0_2_3.html":{"level":2,"children":[],"href":"/release/release_0_2_3.html","text":"napari 0.2.3"},"/release/release_0_2_4.html":{"level":2,"children":[],"href":"/release/release_0_2_4.html","text":"napari 0.2.4"},"/release/release_0_2_5.html":{"level":2,"children":[],"href":"/release/release_0_2_5.html","text":"napari 0.2.5"},"/release/release_0_2_6.html":{"level":2,"children":[],"href":"/release/release_0_2_6.html","text":"napari 0.2.6"},"/release/release_0_2_7.html":{"level":2,"children":[],"href":"/release/release_0_2_7.html","text":"napari 0.2.7"},"/release/release_0_2_8.html":{"level":2,"children":[],"href":"/release/release_0_2_8.html","text":"napari 0.2.8"},"/release/release_0_2_9.html":{"level":2,"children":[],"href":"/release/release_0_2_9.html","text":"napari 0.2.9"},"/release/release_0_2_10.html":{"level":2,"children":[],"href":"/release/release_0_2_10.html","text":"napari 0.2.10"},"/release/release_0_2_11.html":{"level":2,"children":[],"href":"/release/release_0_2_11.html","text":"napari 0.2.11"},"/release/release_0_2_12.html":{"level":2,"children":[],"href":"/release/release_0_2_12.html","text":"napari 0.2.12"},"/release/release_0_3_0.html":{"level":2,"children":[],"href":"/release/release_0_3_0.html","text":"napari 0.3.0"},"/release/release_0_3_1.html":{"level":2,"children":[],"href":"/release/release_0_3_1.html","text":"napari 0.3.1"},"/release/release_0_3_2.html":{"level":2,"children":[],"href":"/release/release_0_3_2.html","text":"napari 0.3.2"},"/release/release_0_3_3.html":{"level":2,"children":[],"href":"/release/release_0_3_3.html","text":"napari 0.3.3"},"/release/release_0_3_4.html":{"level":2,"children":[],"href":"/release/release_0_3_4.html","text":"napari 0.3.4"},"/release/release_0_3_5.html":{"level":2,"children":[],"href":"/release/release_0_3_5.html","text":"napari 0.3.5"},"/release/release_0_3_6.html":{"level":2,"children":[],"href":"/release/release_0_3_6.html","text":"napari 0.3.6"},"/release/release_0_3_7.html":{"level":2,"children":[],"href":"/release/release_0_3_7.html","text":"napari 0.3.7"},"/release/release_0_3_8.html":{"level":2,"children":[],"href":"/release/release_0_3_8.html","text":"napari 0.3.8"},"/release/release_0_4_0.html":{"level":2,"children":[],"href":"/release/release_0_4_0.html","text":"napari 0.4.0"},"/release/release_0_4_1.html":{"level":2,"children":[],"href":"/release/release_0_4_1.html","text":"napari 0.4.1"},"/release/release_0_4_2.html":{"level":2,"children":[],"href":"/release/release_0_4_2.html","text":"napari 0.4.2"},"/release/release_0_4_3.html":{"level":2,"children":[],"href":"/release/release_0_4_3.html","text":"napari 0.4.3"},"/release/release_0_4_4.html":{"level":2,"children":[],"href":"/release/release_0_4_4.html","text":"napari 0.4.4"},"/release/release_0_4_5.html":{"level":2,"children":[],"href":"/release/release_0_4_5.html","text":"napari 0.4.5"},"/release/release_0_4_6.html":{"level":2,"children":[],"href":"/release/release_0_4_6.html","text":"napari 0.4.6"},"/release/release_0_4_7.html":{"level":2,"children":[],"href":"/release/release_0_4_7.html","text":"napari 0.4.7"},"/release/release_0_4_8.html":{"level":2,"children":[],"href":"/release/release_0_4_8.html","text":"napari 0.4.8"},"/release/release_0_4_9.html":{"level":2,"children":[],"href":"/release/release_0_4_9.html","text":"napari 0.4.9"},"/release/release_0_4_10.html":{"level":2,"children":[],"href":"/release/release_0_4_10.html","text":"napari 0.4.10"},"/release/release_0_4_11.html":{"level":2,"children":[],"href":"/release/release_0_4_11.html","text":"napari 0.4.11"},"/release/release_0_4_12.html":{"level":2,"children":[],"href":"/release/release_0_4_12.html","text":"napari 0.4.12"},"/glossary.html":{"level":1,"children":[],"href":"/glossary.html","text":"Glossary"},"/developers/index.html":{"level":1,"children":["/developers/benchmarks.html","/developers/contributing.html","/developers/core_dev_guide.html","/developers/profiling.html","/developers/release.html","/developers/testing.html","/developers/docs.html","/developers/translations.html"],"href":"/developers/index.html","text":"Developer resources"},"/developers/translations.html":{"level":2,"children":[],"href":"/developers/translations.html","text":"Translations"},"/developers/docs.html":{"level":2,"children":[],"href":"/developers/docs.html","text":"Organization of Documentation for napari"},"/developers/testing.html":{"level":2,"children":[],"href":"/developers/testing.html","text":"Testing"},"/developers/release.html":{"level":2,"children":[],"href":"/developers/release.html","text":"Release guide"},"/developers/profiling.html":{"level":2,"children":[],"href":"/developers/profiling.html","text":"Profiling"},"/developers/core_dev_guide.html":{"level":2,"children":[],"href":"/developers/core_dev_guide.html","text":"Core Developer guide"},"/developers/contributing.html":{"level":2,"children":[],"href":"/developers/contributing.html","text":"Contributing guide"},"/developers/benchmarks.html":{"level":2,"children":[],"href":"/developers/benchmarks.html","text":"Benchmarks"},"/api/stable/index.html":{"level":1,"children":["/api/stable/napari.layers.html","/api/stable/napari.view_layers.html","/api/stable/napari.types.html","/api/stable/napari.utils.html","/api/stable/napari.plugins.html","/api/stable/napari.components.html","/api/stable/napari.qt.threading.html","/api/stable/napari.utils.perf.html","/api/stable/napari.html","/api/stable/napari.html"],"href":"/api/stable/index.html","text":"API reference"},"/api/stable/napari.html":{"level":2,"children":["/api/stable/napari.Viewer.html"],"href":"/api/stable/napari.html","text":"napari"},"/api/stable/napari.Viewer.html":{"level":3,"children":[],"href":"/api/stable/napari.Viewer.html","text":"napari.Viewer"},"/api/stable/napari.utils.perf.html":{"level":2,"children":["/api/stable/napari.utils.perf.PerfEvent.html"],"href":"/api/stable/napari.utils.perf.html","text":"napari.utils.perf"},"/api/stable/napari.utils.perf.PerfEvent.html":{"level":3,"children":[],"href":"/api/stable/napari.utils.perf.PerfEvent.html","text":"napari.utils.perf.PerfEvent"},"/api/stable/napari.qt.threading.html":{"level":2,"children":["/api/stable/napari.qt.threading.FunctionWorker.html","/api/stable/napari.qt.threading.GeneratorWorker.html","/api/stable/napari.qt.threading.GeneratorWorkerSignals.html","/api/stable/napari.qt.threading.WorkerBase.html","/api/stable/napari.qt.threading.WorkerBaseSignals.html"],"href":"/api/stable/napari.qt.threading.html","text":"napari.qt.threading"},"/api/stable/napari.qt.threading.WorkerBaseSignals.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.WorkerBaseSignals.html","text":"napari.qt.threading.WorkerBaseSignals"},"/api/stable/napari.qt.threading.WorkerBase.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.WorkerBase.html","text":"napari.qt.threading.WorkerBase"},"/api/stable/napari.qt.threading.GeneratorWorkerSignals.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.GeneratorWorkerSignals.html","text":"napari.qt.threading.GeneratorWorkerSignals"},"/api/stable/napari.qt.threading.GeneratorWorker.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.GeneratorWorker.html","text":"napari.qt.threading.GeneratorWorker"},"/api/stable/napari.qt.threading.FunctionWorker.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.FunctionWorker.html","text":"napari.qt.threading.FunctionWorker"},"/api/stable/napari.components.html":{"level":2,"children":["/api/stable/napari.components.Camera.html","/api/stable/napari.components.Dims.html","/api/stable/napari.components.LayerList.html","/api/stable/napari.components.ViewerModel.html"],"href":"/api/stable/napari.components.html","text":"napari.components"},"/api/stable/napari.components.ViewerModel.html":{"level":3,"children":[],"href":"/api/stable/napari.components.ViewerModel.html","text":"napari.components.ViewerModel"},"/api/stable/napari.components.LayerList.html":{"level":3,"children":[],"href":"/api/stable/napari.components.LayerList.html","text":"napari.components.LayerList"},"/api/stable/napari.components.Dims.html":{"level":3,"children":[],"href":"/api/stable/napari.components.Dims.html","text":"napari.components.Dims"},"/api/stable/napari.components.Camera.html":{"level":3,"children":[],"href":"/api/stable/napari.components.Camera.html","text":"napari.components.Camera"},"/api/stable/napari.plugins.html":{"level":2,"children":["/api/stable/napari.plugins.NapariPluginManager.html"],"href":"/api/stable/napari.plugins.html","text":"napari.plugins"},"/api/stable/napari.plugins.NapariPluginManager.html":{"level":3,"children":[],"href":"/api/stable/napari.plugins.NapariPluginManager.html","text":"napari.plugins.NapariPluginManager"},"/api/stable/napari.utils.html":{"level":2,"children":["/api/stable/napari.utils.Colormap.html","/api/stable/napari.utils.nbscreenshot.html","/api/stable/napari.utils.progress.html"],"href":"/api/stable/napari.utils.html","text":"napari.utils"},"/api/stable/napari.utils.progress.html":{"level":3,"children":[],"href":"/api/stable/napari.utils.progress.html","text":"napari.utils.progress"},"/api/stable/napari.utils.nbscreenshot.html":{"level":3,"children":[],"href":"/api/stable/napari.utils.nbscreenshot.html","text":"napari.utils.nbscreenshot"},"/api/stable/napari.utils.Colormap.html":{"level":3,"children":[],"href":"/api/stable/napari.utils.Colormap.html","text":"napari.utils.Colormap"},"/api/stable/napari.types.html":{"level":2,"children":["/api/stable/napari.types.ArrayBase.html","/api/stable/napari.types.Path.html","/api/stable/napari.types.SampleDict.html","/api/stable/napari.types.TracebackType.html","/api/stable/napari.types.TypedDict.html","/api/stable/napari.types.partial.html"],"href":"/api/stable/napari.types.html","text":"napari.types"},"/api/stable/napari.types.partial.html":{"level":3,"children":[],"href":"/api/stable/napari.types.partial.html","text":"napari.types.partial"},"/api/stable/napari.types.TypedDict.html":{"level":3,"children":[],"href":"/api/stable/napari.types.TypedDict.html","text":"napari.types.TypedDict"},"/api/stable/napari.types.TracebackType.html":{"level":3,"children":[],"href":"/api/stable/napari.types.TracebackType.html","text":"napari.types.TracebackType"},"/api/stable/napari.types.SampleDict.html":{"level":3,"children":[],"href":"/api/stable/napari.types.SampleDict.html","text":"napari.types.SampleDict"},"/api/stable/napari.types.Path.html":{"level":3,"children":[],"href":"/api/stable/napari.types.Path.html","text":"napari.types.Path"},"/api/stable/napari.types.ArrayBase.html":{"level":3,"children":[],"href":"/api/stable/napari.types.ArrayBase.html","text":"napari.types.ArrayBase"},"/api/stable/napari.view_layers.html":{"level":2,"children":["/api/stable/napari.view_layers.Viewer.html"],"href":"/api/stable/napari.view_layers.html","text":"napari.view_layers"},"/api/stable/napari.view_layers.Viewer.html":{"level":3,"children":[],"href":"/api/stable/napari.view_layers.Viewer.html","text":"napari.view_layers.Viewer"},"/api/stable/napari.layers.html":{"level":2,"children":["/api/stable/napari.layers.Image.html","/api/stable/napari.layers.Labels.html","/api/stable/napari.layers.Layer.html","/api/stable/napari.layers.Points.html","/api/stable/napari.layers.Shapes.html","/api/stable/napari.layers.Surface.html","/api/stable/napari.layers.Tracks.html","/api/stable/napari.layers.Vectors.html"],"href":"/api/stable/napari.layers.html","text":"napari.layers"},"/api/stable/napari.layers.Vectors.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Vectors.html","text":"napari.layers.Vectors"},"/api/stable/napari.layers.Tracks.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Tracks.html","text":"napari.layers.Tracks"},"/api/stable/napari.layers.Surface.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Surface.html","text":"napari.layers.Surface"},"/api/stable/napari.layers.Shapes.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Shapes.html","text":"napari.layers.Shapes"},"/api/stable/napari.layers.Points.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Points.html","text":"napari.layers.Points"},"/api/stable/napari.layers.Layer.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Layer.html","text":"napari.layers.Layer"},"/api/stable/napari.layers.Labels.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Labels.html","text":"napari.layers.Labels"},"/api/stable/napari.layers.Image.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Image.html","text":"napari.layers.Image"},"/community/index.html":{"level":1,"children":["/community/mission_and_values.html","/community/team.html","/community/code_of_conduct.html","/community/code_of_conduct_reporting.html","/community/governance.html","/community/working_groups.html"],"href":"/community/index.html","text":"Community"},"/community/working_groups.html":{"level":2,"children":[],"href":"/community/working_groups.html","text":"Working groups"},"/community/governance.html":{"level":2,"children":[],"href":"/community/governance.html","text":"Governance model"},"/community/code_of_conduct_reporting.html":{"level":2,"children":[],"href":"/community/code_of_conduct_reporting.html","text":"Handling Code of Conduct reports"},"/community/code_of_conduct.html":{"level":2,"children":[],"href":"/community/code_of_conduct.html","text":"Code of Conduct"},"/community/team.html":{"level":2,"children":[],"href":"/community/team.html","text":"About the project and team"},"/community/mission_and_values.html":{"level":2,"children":[],"href":"/community/mission_and_values.html","text":"Mission and Values"},"/plugins/stable/index.html":{"level":1,"children":["/plugins/stable/for_plugin_developers.html","/plugins/stable/hook_specifications.html","/plugins/stable/for_napari_developers.html","/plugins/stable/best_practices.html","/plugins/stable/npe2_migration_guide.html","/plugins/stable/npe2_getting_started.html","/plugins/stable/npe2_manifest_specification.html","/plugins/stable/find-and-install-plugin.html"],"href":"/plugins/stable/index.html","text":"Plugins"},"/plugins/stable/find-and-install-plugin.html":{"level":2,"children":[],"href":"/plugins/stable/find-and-install-plugin.html","text":"Finding and installing a napari plugin"},"/plugins/stable/npe2_manifest_specification.html":{"level":2,"children":[],"href":"/plugins/stable/npe2_manifest_specification.html","text":"npe2 manifest specification"},"/plugins/stable/npe2_getting_started.html":{"level":2,"children":[],"href":"/plugins/stable/npe2_getting_started.html","text":"npe2 getting started guide"},"/plugins/stable/npe2_migration_guide.html":{"level":2,"children":[],"href":"/plugins/stable/npe2_migration_guide.html","text":"npe2 migration guide"},"/plugins/stable/best_practices.html":{"level":2,"children":[],"href":"/plugins/stable/best_practices.html","text":"Best practices when developing napari plugins"},"/plugins/stable/for_napari_developers.html":{"level":2,"children":[],"href":"/plugins/stable/for_napari_developers.html","text":"napari plugin architecture"},"/plugins/stable/hook_specifications.html":{"level":2,"children":[],"href":"/plugins/stable/hook_specifications.html","text":"napari hook specification reference"},"/plugins/stable/for_plugin_developers.html":{"level":2,"children":[],"href":"/plugins/stable/for_plugin_developers.html","text":"Creating a napari plugin"},"/guides/stable/index.html":{"level":1,"children":["/guides/stable/magicgui.html","/guides/stable/event_loop.html","/guides/stable/threading.html","/guides/stable/rendering-explanation.html","/guides/stable/rendering.html","/guides/stable/performance.html","/guides/stable/3D_interactivity.html","/guides/stable/events_reference.html","/guides/stable/contexts_expressions.html"],"href":"/guides/stable/index.html","text":"In-depth explanations"},"/guides/stable/contexts_expressions.html":{"level":2,"children":[],"href":"/guides/stable/contexts_expressions.html","text":"Contexts and Expressions in napari"},"/guides/stable/events_reference.html":{"level":2,"children":[],"href":"/guides/stable/events_reference.html","text":"Events reference"},"/guides/stable/3D_interactivity.html":{"level":2,"children":[],"href":"/guides/stable/3D_interactivity.html","text":"3D interactivity"},"/guides/stable/performance.html":{"level":2,"children":[],"href":"/guides/stable/performance.html","text":"napari performance"},"/guides/stable/rendering.html":{"level":2,"children":[],"href":"/guides/stable/rendering.html","text":"Asynchronous rendering"},"/guides/stable/rendering-explanation.html":{"level":2,"children":[],"href":"/guides/stable/rendering-explanation.html","text":"Rendering in napari"},"/guides/stable/threading.html":{"level":2,"children":[],"href":"/guides/stable/threading.html","text":"Multithreading in napari"},"/guides/stable/event_loop.html":{"level":2,"children":[],"href":"/guides/stable/event_loop.html","text":"An introduction to the event loop in napari"},"/guides/stable/magicgui.html":{"level":2,"children":[],"href":"/guides/stable/magicgui.html","text":"Using magicgui in napari"},"/howtos/index.html":{"level":1,"children":["/howtos/connecting_events.html","/howtos/napari_imageJ.html","/howtos/docker.html","/howtos/perfmon.html"],"href":"/howtos/index.html","text":"How-to guides"},"/howtos/perfmon.html":{"level":2,"children":[],"href":"/howtos/perfmon.html","text":"Performance monitoring"},"/howtos/docker.html":{"level":2,"children":[],"href":"/howtos/docker.html","text":"Napari in Docker"},"/howtos/napari_imageJ.html":{"level":2,"children":[],"href":"/howtos/napari_imageJ.html","text":"napari + ImageJ how-to guide"},"/howtos/connecting_events.html":{"level":2,"children":[],"href":"/howtos/connecting_events.html","text":"Hooking up your own events"},"/tutorials/index.html":{"level":1,"children":["/tutorials/segmentation/index.html","/tutorials/tracking/index.html","/tutorials/applications/annotate_points.html","/tutorials/applications/dask.html","/tutorials/further-resources/napari-workshops.html","/tutorials/tracking/cell_tracking.html","/tutorials/segmentation/annotate_segmentation.html"],"href":"/tutorials/index.html","text":"Tutorials"},"/tutorials/segmentation/annotate_segmentation.html":{"level":2,"children":[],"href":"/tutorials/segmentation/annotate_segmentation.html","text":"Annotating segmentation with text and bounding boxes"},"/tutorials/tracking/cell_tracking.html":{"level":2,"children":[],"href":"/tutorials/tracking/cell_tracking.html","text":"Single cell tracking with napari"},"/tutorials/further-resources/napari-workshops.html":{"level":2,"children":[],"href":"/tutorials/further-resources/napari-workshops.html","text":"napari workshops"},"/tutorials/applications/dask.html":{"level":2,"children":[],"href":"/tutorials/applications/dask.html","text":"Using Dask and napari to process & view large datasets"},"/tutorials/applications/annotate_points.html":{"level":2,"children":[],"href":"/tutorials/applications/annotate_points.html","text":"Annotating videos with napari"},"/tutorials/tracking/index.html":{"level":2,"children":[],"href":"/tutorials/tracking/index.html","text":"Tracking"},"/tutorials/segmentation/index.html":{"level":2,"children":[],"href":"/tutorials/segmentation/index.html","text":"Segmentation"},"/tutorials/start_index.html":{"level":1,"children":["/tutorials/fundamentals/installation.html","/tutorials/fundamentals/getting_started.html","/plugins/stable/find-and-install-plugin.html","/tutorials/fundamentals/viewer.html","/tutorials/fundamentals/image.html","/tutorials/fundamentals/labels.html","/tutorials/fundamentals/points.html","/tutorials/fundamentals/shapes.html","/tutorials/fundamentals/surface.html","/tutorials/fundamentals/tracks.html","/tutorials/fundamentals/vectors.html"],"href":"/tutorials/start_index.html","text":"Getting Started"},"/tutorials/fundamentals/vectors.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/vectors.html","text":"vectors layer tutorial"},"/tutorials/fundamentals/tracks.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/tracks.html","text":"tracks layer tutorial"},"/tutorials/fundamentals/surface.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/surface.html","text":"surface layer tutorial"},"/tutorials/fundamentals/shapes.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/shapes.html","text":"shapes layer tutorial"},"/tutorials/fundamentals/points.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/points.html","text":"points layer tutorial"},"/tutorials/fundamentals/labels.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/labels.html","text":"labels layer tutorial"},"/tutorials/fundamentals/image.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/image.html","text":"image layer tutorial"},"/tutorials/fundamentals/viewer.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/viewer.html","text":"napari viewer tutorial"},"/tutorials/fundamentals/getting_started.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/getting_started.html","text":"Getting started with napari"},"/tutorials/fundamentals/installation.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/installation.html","text":"How to install napari on your machine"}},"rootGlobalHeaders":["/tutorials/start_index.html","/tutorials/index.html","/howtos/index.html","/guides/stable/index.html","/plugins/stable/index.html","/community/index.html","/api/stable/index.html","/developers/index.html","/glossary.html","/release/index.html","/roadmaps/index.html","https://github.com/napari/napari","https://napari-hub.org"],"pageTitle":"Source code for typing","pageFrontMatter":{},"previewImage":"","previewDescription":"","appScripts":[{"src":"/_static/documentation_options.js"},{"src":"/_static/jquery.js"},{"src":"/_static/underscore.js"},{"src":"/_static/doctools.js"},{"src":"/_static/togglebutton.js"},{"src":"/_static/clipboard.min.js"},{"src":"/_static/copybutton.js"},{"children":"var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';"}],"appStyleSheets":[{"href":"/_static/pygments.css","rel":"stylesheet"},{"href":"/_static/togglebutton.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/copybutton.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/mystnb.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/sphinx-thebe.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/panels-variables.06eb56fa6e07937060861dad626602ad.css","rel":"stylesheet","type":"text/css"}],"pageBodyHtml":"\n        <div id=\"documentation_options\" data-url_root=\"../\"></div>\n        <div class=\"highlight\"><pre><span></span><span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">The typing module: Support for gradual typing as defined by PEP 484.</span>\n\n<span class=\"sd\">At large scale, the structure of the module is following:</span>\n<span class=\"sd\">* Imports and exports, all public names should be explicitly added to __all__.</span>\n<span class=\"sd\">* Internal helper functions: these should never be used in code outside this module.</span>\n<span class=\"sd\">* _SpecialForm and its instances (special forms): Any, NoReturn, ClassVar, Union, Optional</span>\n<span class=\"sd\">* Two classes whose instances can be type arguments in addition to types: ForwardRef and TypeVar</span>\n<span class=\"sd\">* The core of internal generics API: _GenericAlias and _VariadicGenericAlias, the latter is</span>\n<span class=\"sd\">  currently only used by Tuple and Callable. All subscripted types like X[int], Union[int, str],</span>\n<span class=\"sd\">  etc., are instances of either of these classes.</span>\n<span class=\"sd\">* The public counterpart of the generics API consists of two classes: Generic and Protocol.</span>\n<span class=\"sd\">* Public helper functions: get_type_hints, overload, cast, no_type_check,</span>\n<span class=\"sd\">  no_type_check_decorator.</span>\n<span class=\"sd\">* Generic aliases for collections.abc ABCs and few additional protocols.</span>\n<span class=\"sd\">* Special types: NewType, NamedTuple, TypedDict.</span>\n<span class=\"sd\">* Wrapper submodules for re and io related types.</span>\n<span class=\"sd\">\"\"\"</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">abc</span> <span class=\"kn\">import</span> <span class=\"n\">abstractmethod</span><span class=\"p\">,</span> <span class=\"n\">ABCMeta</span>\n<span class=\"kn\">import</span> <span class=\"nn\">collections</span>\n<span class=\"kn\">import</span> <span class=\"nn\">collections.abc</span>\n<span class=\"kn\">import</span> <span class=\"nn\">contextlib</span>\n<span class=\"kn\">import</span> <span class=\"nn\">functools</span>\n<span class=\"kn\">import</span> <span class=\"nn\">operator</span>\n<span class=\"kn\">import</span> <span class=\"nn\">re</span> <span class=\"k\">as</span> <span class=\"nn\">stdlib_re</span>  <span class=\"c1\"># Avoid confusion with the re we export.</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">types</span>\n<span class=\"kn\">from</span> <span class=\"nn\">types</span> <span class=\"kn\">import</span> <span class=\"n\">WrapperDescriptorType</span><span class=\"p\">,</span> <span class=\"n\">MethodWrapperType</span><span class=\"p\">,</span> <span class=\"n\">MethodDescriptorType</span>\n\n<span class=\"c1\"># Please keep __all__ alphabetized within each category.</span>\n<span class=\"n\">__all__</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"c1\"># Super-special typing primitives.</span>\n    <span class=\"s1\">'Any'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Callable'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'ClassVar'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Final'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'ForwardRef'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Generic'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Literal'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Optional'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Protocol'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Tuple'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Type'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'TypeVar'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Union'</span><span class=\"p\">,</span>\n\n    <span class=\"c1\"># ABCs (from collections.abc).</span>\n    <span class=\"s1\">'AbstractSet'</span><span class=\"p\">,</span>  <span class=\"c1\"># collections.abc.Set.</span>\n    <span class=\"s1\">'ByteString'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Container'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'ContextManager'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Hashable'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'ItemsView'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Iterable'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Iterator'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'KeysView'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Mapping'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'MappingView'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'MutableMapping'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'MutableSequence'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'MutableSet'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Sequence'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Sized'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'ValuesView'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Awaitable'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'AsyncIterator'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'AsyncIterable'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Coroutine'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Collection'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'AsyncGenerator'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'AsyncContextManager'</span><span class=\"p\">,</span>\n\n    <span class=\"c1\"># Structural checks, a.k.a. protocols.</span>\n    <span class=\"s1\">'Reversible'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'SupportsAbs'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'SupportsBytes'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'SupportsComplex'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'SupportsFloat'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'SupportsIndex'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'SupportsInt'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'SupportsRound'</span><span class=\"p\">,</span>\n\n    <span class=\"c1\"># Concrete collection types.</span>\n    <span class=\"s1\">'ChainMap'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Counter'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Deque'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Dict'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'DefaultDict'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'List'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'OrderedDict'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Set'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'FrozenSet'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'NamedTuple'</span><span class=\"p\">,</span>  <span class=\"c1\"># Not really a type.</span>\n    <span class=\"s1\">'TypedDict'</span><span class=\"p\">,</span>  <span class=\"c1\"># Not really a type.</span>\n    <span class=\"s1\">'Generator'</span><span class=\"p\">,</span>\n\n    <span class=\"c1\"># One-off things.</span>\n    <span class=\"s1\">'AnyStr'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'cast'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'final'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'get_args'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'get_origin'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'get_type_hints'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'NewType'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'no_type_check'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'no_type_check_decorator'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'NoReturn'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'overload'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'runtime_checkable'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'Text'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'TYPE_CHECKING'</span><span class=\"p\">,</span>\n<span class=\"p\">]</span>\n\n<span class=\"c1\"># The pseudo-submodules 're' and 'io' are part of the public</span>\n<span class=\"c1\"># namespace, but excluded from __all__ because they might stomp on</span>\n<span class=\"c1\"># legitimate imports of those modules.</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_type_check</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"n\">is_argument</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Check that the argument is a type, and return it (internal helper).</span>\n\n<span class=\"sd\">    As a special case, accept None and return type(None) instead. Also wrap strings</span>\n<span class=\"sd\">    into ForwardRef instances. Consider several corner cases, for example plain</span>\n<span class=\"sd\">    special forms like Union are not valid, while Union[int, str] is OK, etc.</span>\n<span class=\"sd\">    The msg argument is a human-readable error message, e.g::</span>\n\n<span class=\"sd\">        \"Union[arg, ...]: arg should be a type.\"</span>\n\n<span class=\"sd\">    We append the repr() of the actual value (truncated to 100 chars).</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"n\">invalid_generic_forms</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">Protocol</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">is_argument</span><span class=\"p\">:</span>\n        <span class=\"n\">invalid_generic_forms</span> <span class=\"o\">=</span> <span class=\"n\">invalid_generic_forms</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">ClassVar</span><span class=\"p\">,</span> <span class=\"n\">Final</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">arg</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n            <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">in</span> <span class=\"n\">invalid_generic_forms</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"</span><span class=\"si\">{</span><span class=\"n\">arg</span><span class=\"si\">}</span><span class=\"s2\"> is not valid as type argument\"</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">arg</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"n\">NoReturn</span><span class=\"p\">)</span> <span class=\"ow\">or</span>\n            <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">Protocol</span><span class=\"p\">)):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Plain </span><span class=\"si\">{</span><span class=\"n\">arg</span><span class=\"si\">}</span><span class=\"s2\"> is not valid as type argument\"</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">,</span> <span class=\"n\">TypeVar</span><span class=\"p\">,</span> <span class=\"n\">ForwardRef</span><span class=\"p\">)):</span>\n        <span class=\"k\">return</span> <span class=\"n\">arg</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">callable</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"</span><span class=\"si\">{</span><span class=\"n\">msg</span><span class=\"si\">}</span><span class=\"s2\"> Got </span><span class=\"si\">{</span><span class=\"n\">arg</span><span class=\"si\">!r:</span><span class=\"s2\">.100</span><span class=\"si\">}</span><span class=\"s2\">.\"</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">arg</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_type_repr</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Return the repr() of an object, special-casing types (internal helper).</span>\n\n<span class=\"sd\">    If obj is a type, we return a shorter version than the default</span>\n<span class=\"sd\">    type.__repr__, based on the module and qualified name, which is</span>\n<span class=\"sd\">    typically enough to uniquely identify a type.  For everything</span>\n<span class=\"sd\">    else, we fall back on repr(obj).</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__module__</span> <span class=\"o\">==</span> <span class=\"s1\">'builtins'</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n        <span class=\"k\">return</span> <span class=\"sa\">f</span><span class=\"s1\">'</span><span class=\"si\">{</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__module__</span><span class=\"si\">}</span><span class=\"s1\">.</span><span class=\"si\">{</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span><span class=\"si\">}</span><span class=\"s1\">'</span>\n    <span class=\"k\">if</span> <span class=\"n\">obj</span> <span class=\"ow\">is</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span><span class=\"p\">(</span><span class=\"s1\">'...'</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">FunctionType</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n    <span class=\"k\">return</span> <span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_collect_type_vars</span><span class=\"p\">(</span><span class=\"n\">types</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Collect all type variable contained in types in order of</span>\n<span class=\"sd\">    first appearance (lexicographic order). For example::</span>\n\n<span class=\"sd\">        _collect_type_vars((T, List[S, T])) == (T, S)</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"n\">tvars</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">TypeVar</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">t</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">tvars</span><span class=\"p\">:</span>\n            <span class=\"n\">tvars</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"n\">tvars</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">([</span><span class=\"n\">t</span> <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span> <span class=\"k\">if</span> <span class=\"n\">t</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">tvars</span><span class=\"p\">])</span>\n    <span class=\"k\">return</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">tvars</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_subs_tvars</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">,</span> <span class=\"n\">tvars</span><span class=\"p\">,</span> <span class=\"n\">subs</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Substitute type variables 'tvars' with substitutions 'subs'.</span>\n<span class=\"sd\">    These two must have the same length.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">tp</span>\n    <span class=\"n\">new_args</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">TypeVar</span><span class=\"p\">):</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">tvar</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">tvars</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">arg</span> <span class=\"o\">==</span> <span class=\"n\">tvar</span><span class=\"p\">:</span>\n                    <span class=\"n\">new_args</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">subs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">new_args</span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">_subs_tvars</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">tvars</span><span class=\"p\">,</span> <span class=\"n\">subs</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">new_args</span><span class=\"p\">)]</span>\n    <span class=\"k\">return</span> <span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">(</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">new_args</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_check_generic</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Check correct count for parameters of a generic cls (internal helper).</span>\n<span class=\"sd\">    This gives a nice error message in case of count mismatch.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"</span><span class=\"si\">{</span><span class=\"bp\">cls</span><span class=\"si\">}</span><span class=\"s2\"> is not a generic class\"</span><span class=\"p\">)</span>\n    <span class=\"n\">alen</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n    <span class=\"n\">elen</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">alen</span> <span class=\"o\">!=</span> <span class=\"n\">elen</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Too </span><span class=\"si\">{</span><span class=\"s1\">'many'</span> <span class=\"k\">if</span> <span class=\"n\">alen</span> <span class=\"o\">&gt;</span> <span class=\"n\">elen</span> <span class=\"k\">else</span> <span class=\"s1\">'few'</span><span class=\"si\">}</span><span class=\"s2\"> parameters for </span><span class=\"si\">{</span><span class=\"bp\">cls</span><span class=\"si\">}</span><span class=\"s2\">;\"</span>\n                        <span class=\"sa\">f</span><span class=\"s2\">\" actual </span><span class=\"si\">{</span><span class=\"n\">alen</span><span class=\"si\">}</span><span class=\"s2\">, expected </span><span class=\"si\">{</span><span class=\"n\">elen</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_remove_dups_flatten</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"An internal helper for Union creation and substitution: flatten Unions</span>\n<span class=\"sd\">    among parameters, then remove duplicates.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"c1\"># Flatten out Union[Union[...], ...].</span>\n    <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n            <span class=\"n\">params</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span> <span class=\"ow\">and</span> <span class=\"n\">p</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n            <span class=\"n\">params</span><span class=\"o\">.</span><span class=\"n\">extend</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:])</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">params</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Weed out strict duplicates, preserving the first of each occurrence.</span>\n    <span class=\"n\">all_params</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">all_params</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"n\">new_params</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">all_params</span><span class=\"p\">:</span>\n                <span class=\"n\">new_params</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n                <span class=\"n\">all_params</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n        <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"n\">new_params</span>\n        <span class=\"k\">assert</span> <span class=\"ow\">not</span> <span class=\"n\">all_params</span><span class=\"p\">,</span> <span class=\"n\">all_params</span>\n    <span class=\"k\">return</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">_cleanups</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_tp_cache</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Internal wrapper caching __getitem__ of generic types with a fallback to</span>\n<span class=\"sd\">    original function for non-hashable arguments.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"n\">cached</span> <span class=\"o\">=</span> <span class=\"n\">functools</span><span class=\"o\">.</span><span class=\"n\">lru_cache</span><span class=\"p\">()(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"n\">_cleanups</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">cached</span><span class=\"o\">.</span><span class=\"n\">cache_clear</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@functools</span><span class=\"o\">.</span><span class=\"n\">wraps</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">inner</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">cached</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">)</span>\n        <span class=\"k\">except</span> <span class=\"ne\">TypeError</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>  <span class=\"c1\"># All real errors (not unhashable args) are raised below.</span>\n        <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">inner</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_eval_type</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Evaluate all forward references in the given type t.</span>\n<span class=\"sd\">    For use of globalns and localns see the docstring for get_type_hints().</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">ForwardRef</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">_evaluate</span><span class=\"p\">(</span><span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">):</span>\n        <span class=\"n\">ev_args</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_eval_type</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">ev_args</span> <span class=\"o\">==</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">t</span>\n        <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">(</span><span class=\"n\">ev_args</span><span class=\"p\">)</span>\n        <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">_special</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">_special</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span>\n    <span class=\"k\">return</span> <span class=\"n\">t</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_Final</span><span class=\"p\">:</span>\n    <span class=\"sd\">\"\"\"Mixin to prohibit subclassing\"\"\"</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'__weakref__'</span><span class=\"p\">,)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__init_subclass__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"s1\">'_root'</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">kwds</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Cannot subclass special typing classes\"</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">_Immutable</span><span class=\"p\">:</span>\n    <span class=\"sd\">\"\"\"Mixin to indicate that object should not be copied.\"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__copy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__deepcopy__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">memo</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_SpecialForm</span><span class=\"p\">(</span><span class=\"n\">_Final</span><span class=\"p\">,</span> <span class=\"n\">_Immutable</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Internal indicator of special typing constructs.</span>\n<span class=\"sd\">    See _doc instance attribute for specific docs.</span>\n<span class=\"sd\">    \"\"\"</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'_name'</span><span class=\"p\">,</span> <span class=\"s1\">'_doc'</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Constructor.</span>\n\n<span class=\"sd\">        This only exists to give a better error message in case</span>\n<span class=\"sd\">        someone tries to subclass a special typing object (not a good idea).</span>\n<span class=\"sd\">        \"\"\"</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">3</span> <span class=\"ow\">and</span>\n                <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n                <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">)):</span>\n            <span class=\"c1\"># Close enough.</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Cannot subclass </span><span class=\"si\">{</span><span class=\"bp\">cls</span><span class=\"si\">!r}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_doc</span> <span class=\"o\">=</span> <span class=\"n\">doc</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">((</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">,))</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"s1\">'typing.'</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Cannot instantiate </span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"si\">!r}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__instancecheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"</span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"si\">}</span><span class=\"s2\"> cannot be used with isinstance()\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__subclasscheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"</span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"si\">}</span><span class=\"s2\"> cannot be used with issubclass()\"</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@_tp_cache</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"s1\">'ClassVar'</span><span class=\"p\">,</span> <span class=\"s1\">'Final'</span><span class=\"p\">):</span>\n            <span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"sa\">f</span><span class=\"s1\">'</span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"si\">}</span><span class=\"s1\"> accepts only single type.'</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">,))</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">==</span> <span class=\"s1\">'Union'</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">parameters</span> <span class=\"o\">==</span> <span class=\"p\">():</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Cannot take a Union of no types.\"</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n                <span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">,)</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"Union[arg, ...]: each arg must be a type.\"</span>\n            <span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n            <span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"n\">_remove_dups_flatten</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"n\">parameters</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n            <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">==</span> <span class=\"s1\">'Optional'</span><span class=\"p\">:</span>\n            <span class=\"n\">arg</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"s2\">\"Optional[t] requires a single type.\"</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)]</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">==</span> <span class=\"s1\">'Literal'</span><span class=\"p\">:</span>\n            <span class=\"c1\"># There is no '_type_check' call because arguments to Literal[...] are</span>\n            <span class=\"c1\"># values, not types.</span>\n            <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"</span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"si\">}</span><span class=\"s2\"> is not subscriptable\"</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">'Any'</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">\"\"\"Special type indicating an unconstrained type.</span>\n\n<span class=\"sd\">    - Any is compatible with every type.</span>\n<span class=\"sd\">    - Any assumed to have all methods.</span>\n<span class=\"sd\">    - All values assumed to be instances of Any.</span>\n\n<span class=\"sd\">    Note that all the above statements are true from the point of view of</span>\n<span class=\"sd\">    static type checkers. At runtime, Any should not be used with instance</span>\n<span class=\"sd\">    or class checks.</span>\n<span class=\"sd\">    \"\"\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">NoReturn</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">'NoReturn'</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">\"\"\"Special type indicating functions that never return.</span>\n<span class=\"sd\">    Example::</span>\n\n<span class=\"sd\">      from typing import NoReturn</span>\n\n<span class=\"sd\">      def stop() -&gt; NoReturn:</span>\n<span class=\"sd\">          raise Exception('no way')</span>\n\n<span class=\"sd\">    This type is invalid in other positions, e.g., ``List[NoReturn]``</span>\n<span class=\"sd\">    will fail in static type checkers.</span>\n<span class=\"sd\">    \"\"\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">ClassVar</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">'ClassVar'</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">\"\"\"Special type construct to mark class variables.</span>\n\n<span class=\"sd\">    An annotation wrapped in ClassVar indicates that a given</span>\n<span class=\"sd\">    attribute is intended to be used as a class variable and</span>\n<span class=\"sd\">    should not be set on instances of that class. Usage::</span>\n\n<span class=\"sd\">      class Starship:</span>\n<span class=\"sd\">          stats: ClassVar[Dict[str, int]] = {} # class variable</span>\n<span class=\"sd\">          damage: int = 10                     # instance variable</span>\n\n<span class=\"sd\">    ClassVar accepts only types and cannot be further subscribed.</span>\n\n<span class=\"sd\">    Note that ClassVar is not a class itself, and should not</span>\n<span class=\"sd\">    be used with isinstance() or issubclass().</span>\n<span class=\"sd\">    \"\"\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">Final</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">'Final'</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">\"\"\"Special typing construct to indicate final names to type checkers.</span>\n\n<span class=\"sd\">    A final name cannot be re-assigned or overridden in a subclass.</span>\n<span class=\"sd\">    For example:</span>\n\n<span class=\"sd\">      MAX_SIZE: Final = 9000</span>\n<span class=\"sd\">      MAX_SIZE += 1  # Error reported by type checker</span>\n\n<span class=\"sd\">      class Connection:</span>\n<span class=\"sd\">          TIMEOUT: Final[int] = 10</span>\n\n<span class=\"sd\">      class FastConnector(Connection):</span>\n<span class=\"sd\">          TIMEOUT = 1  # Error reported by type checker</span>\n\n<span class=\"sd\">    There is no runtime checking of these properties.</span>\n<span class=\"sd\">    \"\"\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">Union</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">'Union'</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">\"\"\"Union type; Union[X, Y] means either X or Y.</span>\n\n<span class=\"sd\">    To define a union, use e.g. Union[int, str].  Details:</span>\n<span class=\"sd\">    - The arguments must be types and there must be at least one.</span>\n<span class=\"sd\">    - None as an argument is a special case and is replaced by</span>\n<span class=\"sd\">      type(None).</span>\n<span class=\"sd\">    - Unions of unions are flattened, e.g.::</span>\n\n<span class=\"sd\">        Union[Union[int, str], float] == Union[int, str, float]</span>\n\n<span class=\"sd\">    - Unions of a single argument vanish, e.g.::</span>\n\n<span class=\"sd\">        Union[int] == int  # The constructor actually returns int</span>\n\n<span class=\"sd\">    - Redundant arguments are skipped, e.g.::</span>\n\n<span class=\"sd\">        Union[int, str, int] == Union[int, str]</span>\n\n<span class=\"sd\">    - When comparing unions, the argument order is ignored, e.g.::</span>\n\n<span class=\"sd\">        Union[int, str] == Union[str, int]</span>\n\n<span class=\"sd\">    - You cannot subclass or instantiate a union.</span>\n<span class=\"sd\">    - You can use Optional[X] as a shorthand for Union[X, None].</span>\n<span class=\"sd\">    \"\"\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">Optional</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">'Optional'</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">\"\"\"Optional type.</span>\n\n<span class=\"sd\">    Optional[X] is equivalent to Union[X, None].</span>\n<span class=\"sd\">    \"\"\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">Literal</span> <span class=\"o\">=</span> <span class=\"n\">_SpecialForm</span><span class=\"p\">(</span><span class=\"s1\">'Literal'</span><span class=\"p\">,</span> <span class=\"n\">doc</span><span class=\"o\">=</span>\n    <span class=\"sd\">\"\"\"Special typing form to define literal types (a.k.a. value types).</span>\n\n<span class=\"sd\">    This form can be used to indicate to type checkers that the corresponding</span>\n<span class=\"sd\">    variable or function parameter has a value equivalent to the provided</span>\n<span class=\"sd\">    literal (or one of several literals):</span>\n\n<span class=\"sd\">      def validate_simple(data: Any) -&gt; Literal[True]:  # always returns True</span>\n<span class=\"sd\">          ...</span>\n\n<span class=\"sd\">      MODE = Literal['r', 'rb', 'w', 'wb']</span>\n<span class=\"sd\">      def open_helper(file: str, mode: MODE) -&gt; str:</span>\n<span class=\"sd\">          ...</span>\n\n<span class=\"sd\">      open_helper('/some/path', 'r')  # Passes type check</span>\n<span class=\"sd\">      open_helper('/other/path', 'typo')  # Error in type checker</span>\n\n<span class=\"sd\">   Literal[...] cannot be subclassed. At runtime, an arbitrary value</span>\n<span class=\"sd\">   is allowed as type argument to Literal[...], but type checkers may</span>\n<span class=\"sd\">   impose restrictions.</span>\n<span class=\"sd\">    \"\"\"</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">ForwardRef</span><span class=\"p\">(</span><span class=\"n\">_Final</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Internal wrapper to hold a forward reference.\"\"\"</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'__forward_arg__'</span><span class=\"p\">,</span> <span class=\"s1\">'__forward_code__'</span><span class=\"p\">,</span>\n                 <span class=\"s1\">'__forward_evaluated__'</span><span class=\"p\">,</span> <span class=\"s1\">'__forward_value__'</span><span class=\"p\">,</span>\n                 <span class=\"s1\">'__forward_is_argument__'</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">is_argument</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">):</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Forward reference must be a string -- got </span><span class=\"si\">{</span><span class=\"n\">arg</span><span class=\"si\">!r}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"nb\">compile</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"s1\">'&lt;string&gt;'</span><span class=\"p\">,</span> <span class=\"s1\">'eval'</span><span class=\"p\">)</span>\n        <span class=\"k\">except</span> <span class=\"ne\">SyntaxError</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">SyntaxError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Forward reference must be an expression -- got </span><span class=\"si\">{</span><span class=\"n\">arg</span><span class=\"si\">!r}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span> <span class=\"o\">=</span> <span class=\"n\">arg</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_code__</span> <span class=\"o\">=</span> <span class=\"n\">code</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_evaluated__</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_is_argument__</span> <span class=\"o\">=</span> <span class=\"n\">is_argument</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">_evaluate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_evaluated__</span> <span class=\"ow\">or</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"n\">globalns</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">globalns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span> <span class=\"ow\">and</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">globalns</span> <span class=\"o\">=</span> <span class=\"n\">localns</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n            <span class=\"k\">elif</span> <span class=\"n\">globalns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">globalns</span> <span class=\"o\">=</span> <span class=\"n\">localns</span>\n            <span class=\"k\">elif</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">localns</span> <span class=\"o\">=</span> <span class=\"n\">globalns</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span>\n                <span class=\"nb\">eval</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_code__</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">),</span>\n                <span class=\"s2\">\"Forward references must evaluate to types.\"</span><span class=\"p\">,</span>\n                <span class=\"n\">is_argument</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_is_argument__</span><span class=\"p\">)</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_evaluated__</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">ForwardRef</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_evaluated__</span> <span class=\"ow\">and</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__forward_evaluated__</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span> <span class=\"ow\">and</span>\n                    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__forward_value__</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"sa\">f</span><span class=\"s1\">'ForwardRef(</span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__forward_arg__</span><span class=\"si\">!r}</span><span class=\"s1\">)'</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">TypeVar</span><span class=\"p\">(</span><span class=\"n\">_Final</span><span class=\"p\">,</span> <span class=\"n\">_Immutable</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Type variable.</span>\n\n<span class=\"sd\">    Usage::</span>\n\n<span class=\"sd\">      T = TypeVar('T')  # Can be anything</span>\n<span class=\"sd\">      A = TypeVar('A', str, bytes)  # Must be str or bytes</span>\n\n<span class=\"sd\">    Type variables exist primarily for the benefit of static type</span>\n<span class=\"sd\">    checkers.  They serve as the parameters for generic types as well</span>\n<span class=\"sd\">    as for generic function definitions.  See class Generic for more</span>\n<span class=\"sd\">    information on generic types.  Generic functions work as follows:</span>\n\n<span class=\"sd\">      def repeat(x: T, n: int) -&gt; List[T]:</span>\n<span class=\"sd\">          '''Return a list containing n references to x.'''</span>\n<span class=\"sd\">          return [x]*n</span>\n\n<span class=\"sd\">      def longest(x: A, y: A) -&gt; A:</span>\n<span class=\"sd\">          '''Return the longest of two strings.'''</span>\n<span class=\"sd\">          return x if len(x) &gt;= len(y) else y</span>\n\n<span class=\"sd\">    The latter example's signature is essentially the overloading</span>\n<span class=\"sd\">    of (str, str) -&gt; str and (bytes, bytes) -&gt; bytes.  Also note</span>\n<span class=\"sd\">    that if the arguments are instances of some subclass of str,</span>\n<span class=\"sd\">    the return type is still plain str.</span>\n\n<span class=\"sd\">    At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.</span>\n\n<span class=\"sd\">    Type variables defined with covariant=True or contravariant=True</span>\n<span class=\"sd\">    can be used to declare covariant or contravariant generic types.</span>\n<span class=\"sd\">    See PEP 484 for more details. By default generic types are invariant</span>\n<span class=\"sd\">    in all type variables.</span>\n\n<span class=\"sd\">    Type variables can be introspected. e.g.:</span>\n\n<span class=\"sd\">      T.__name__ == 'T'</span>\n<span class=\"sd\">      T.__constraints__ == ()</span>\n<span class=\"sd\">      T.__covariant__ == False</span>\n<span class=\"sd\">      T.__contravariant__ = False</span>\n<span class=\"sd\">      A.__constraints__ == (str, bytes)</span>\n\n<span class=\"sd\">    Note that only type variables defined in global scope can be pickled.</span>\n<span class=\"sd\">    \"\"\"</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'__name__'</span><span class=\"p\">,</span> <span class=\"s1\">'__bound__'</span><span class=\"p\">,</span> <span class=\"s1\">'__constraints__'</span><span class=\"p\">,</span>\n                 <span class=\"s1\">'__covariant__'</span><span class=\"p\">,</span> <span class=\"s1\">'__contravariant__'</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">constraints</span><span class=\"p\">,</span> <span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n                 <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">contravariant</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n        <span class=\"k\">if</span> <span class=\"n\">covariant</span> <span class=\"ow\">and</span> <span class=\"n\">contravariant</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s2\">\"Bivariant types are not supported.\"</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__covariant__</span> <span class=\"o\">=</span> <span class=\"nb\">bool</span><span class=\"p\">(</span><span class=\"n\">covariant</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__contravariant__</span> <span class=\"o\">=</span> <span class=\"nb\">bool</span><span class=\"p\">(</span><span class=\"n\">contravariant</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">constraints</span> <span class=\"ow\">and</span> <span class=\"n\">bound</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Constraints cannot be combined with bound=...\"</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">constraints</span> <span class=\"ow\">and</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">constraints</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"A single constraint is not allowed\"</span><span class=\"p\">)</span>\n        <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"TypeVar(name, constraint, ...): constraints must be types.\"</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__constraints__</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">constraints</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">bound</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__bound__</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">bound</span><span class=\"p\">,</span> <span class=\"s2\">\"Bound must be a type.\"</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__bound__</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">def_mod</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">_getframe</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">f_globals</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'__name__'</span><span class=\"p\">,</span> <span class=\"s1\">'__main__'</span><span class=\"p\">)</span>  <span class=\"c1\"># for pickling</span>\n        <span class=\"k\">except</span> <span class=\"p\">(</span><span class=\"ne\">AttributeError</span><span class=\"p\">,</span> <span class=\"ne\">ValueError</span><span class=\"p\">):</span>\n            <span class=\"n\">def_mod</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n        <span class=\"k\">if</span> <span class=\"n\">def_mod</span> <span class=\"o\">!=</span> <span class=\"s1\">'typing'</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__module__</span> <span class=\"o\">=</span> <span class=\"n\">def_mod</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__covariant__</span><span class=\"p\">:</span>\n            <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"s1\">'+'</span>\n        <span class=\"k\">elif</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__contravariant__</span><span class=\"p\">:</span>\n            <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"s1\">'-'</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"s1\">'~'</span>\n        <span class=\"k\">return</span> <span class=\"n\">prefix</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n\n\n<span class=\"c1\"># Special typing constructs Union, Optional, Generic, Callable and Tuple</span>\n<span class=\"c1\"># use three special attributes for internal bookkeeping of generic types:</span>\n<span class=\"c1\"># * __parameters__ is a tuple of unique free type parameters of a generic</span>\n<span class=\"c1\">#   type, for example, Dict[T, T].__parameters__ == (T,);</span>\n<span class=\"c1\"># * __origin__ keeps a reference to a type that was subscripted,</span>\n<span class=\"c1\">#   e.g., Union[T, int].__origin__ == Union, or the non-generic version of</span>\n<span class=\"c1\">#   the type.</span>\n<span class=\"c1\"># * __args__ is a tuple of all arguments used in subscripting,</span>\n<span class=\"c1\">#   e.g., Dict[T, int].__args__ == (T, int).</span>\n\n\n<span class=\"c1\"># Mapping from non-generic type names that have a generic alias in typing</span>\n<span class=\"c1\"># but with a different name.</span>\n<span class=\"n\">_normalize_alias</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'list'</span><span class=\"p\">:</span> <span class=\"s1\">'List'</span><span class=\"p\">,</span>\n                    <span class=\"s1\">'tuple'</span><span class=\"p\">:</span> <span class=\"s1\">'Tuple'</span><span class=\"p\">,</span>\n                    <span class=\"s1\">'dict'</span><span class=\"p\">:</span> <span class=\"s1\">'Dict'</span><span class=\"p\">,</span>\n                    <span class=\"s1\">'set'</span><span class=\"p\">:</span> <span class=\"s1\">'Set'</span><span class=\"p\">,</span>\n                    <span class=\"s1\">'frozenset'</span><span class=\"p\">:</span> <span class=\"s1\">'FrozenSet'</span><span class=\"p\">,</span>\n                    <span class=\"s1\">'deque'</span><span class=\"p\">:</span> <span class=\"s1\">'Deque'</span><span class=\"p\">,</span>\n                    <span class=\"s1\">'defaultdict'</span><span class=\"p\">:</span> <span class=\"s1\">'DefaultDict'</span><span class=\"p\">,</span>\n                    <span class=\"s1\">'type'</span><span class=\"p\">:</span> <span class=\"s1\">'Type'</span><span class=\"p\">,</span>\n                    <span class=\"s1\">'Set'</span><span class=\"p\">:</span> <span class=\"s1\">'AbstractSet'</span><span class=\"p\">}</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">_is_dunder</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"s1\">'__'</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">endswith</span><span class=\"p\">(</span><span class=\"s1\">'__'</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_GenericAlias</span><span class=\"p\">(</span><span class=\"n\">_Final</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"The central part of internal API.</span>\n\n<span class=\"sd\">    This represents a generic version of type 'origin' with type arguments 'params'.</span>\n<span class=\"sd\">    There are two kind of these aliases: user defined and special. The special ones</span>\n<span class=\"sd\">    are wrappers around builtin collections and ABCs in collections.abc. These must</span>\n<span class=\"sd\">    have 'name' always set. If 'inst' is False, then the alias can't be instantiated,</span>\n<span class=\"sd\">    this is used by e.g. typing.List and typing.Dict.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">origin</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">special</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_inst</span> <span class=\"o\">=</span> <span class=\"n\">inst</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span> <span class=\"o\">=</span> <span class=\"n\">special</span>\n        <span class=\"k\">if</span> <span class=\"n\">special</span> <span class=\"ow\">and</span> <span class=\"n\">name</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">orig_name</span> <span class=\"o\">=</span> <span class=\"n\">origin</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n            <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">_normalize_alias</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">orig_name</span><span class=\"p\">,</span> <span class=\"n\">orig_name</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"o\">=</span> <span class=\"n\">origin</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"o\">...</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"ow\">is</span> <span class=\"n\">_TypingEllipsis</span> <span class=\"k\">else</span>\n                              <span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"ow\">is</span> <span class=\"n\">_TypingEmpty</span> <span class=\"k\">else</span>\n                              <span class=\"n\">a</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span> <span class=\"o\">=</span> <span class=\"n\">_collect_type_vars</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>  <span class=\"c1\"># This is not documented.</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">name</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__module__</span> <span class=\"o\">=</span> <span class=\"n\">origin</span><span class=\"o\">.</span><span class=\"vm\">__module__</span>\n\n    <span class=\"nd\">@_tp_cache</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">Protocol</span><span class=\"p\">):</span>\n            <span class=\"c1\"># Can't subscript Generic[...] or Protocol[...].</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Cannot subscript already-subscripted </span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,)</span>\n        <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"Parameters to generic types must be types.\"</span>\n        <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"n\">_check_generic</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">_subs_tvars</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">copy_with</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"c1\"># We don't copy self._special.</span>\n        <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_inst</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__repr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">!=</span> <span class=\"s1\">'Callable'</span> <span class=\"ow\">or</span>\n                <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"bp\">Ellipsis</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">:</span>\n                <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'typing.'</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">_type_repr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n                <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"sa\">f</span><span class=\"s1\">'[</span><span class=\"si\">{</span><span class=\"s2\">\", \"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">([</span><span class=\"n\">_type_repr</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">])</span><span class=\"si\">}</span><span class=\"s1\">]'</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"s1\">''</span>\n            <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'</span><span class=\"si\">{</span><span class=\"n\">name</span><span class=\"si\">}{</span><span class=\"n\">args</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"s1\">'typing.Callable'</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'typing.Callable'</span>\n                <span class=\"sa\">f</span><span class=\"s1\">'[[</span><span class=\"si\">{</span><span class=\"s2\">\", \"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">([</span><span class=\"n\">_type_repr</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]])</span><span class=\"si\">}</span><span class=\"s1\">], '</span>\n                <span class=\"sa\">f</span><span class=\"s1\">'</span><span class=\"si\">{</span><span class=\"n\">_type_repr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"si\">}</span><span class=\"s1\">]'</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__eq__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"o\">!=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"kc\">False</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span> <span class=\"ow\">and</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"nb\">frozenset</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">frozenset</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span> <span class=\"o\">==</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">__args__</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__hash__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Union</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">((</span><span class=\"n\">Union</span><span class=\"p\">,</span> <span class=\"nb\">frozenset</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)))</span>\n        <span class=\"k\">return</span> <span class=\"nb\">hash</span><span class=\"p\">((</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_inst</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Type </span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"si\">}</span><span class=\"s2\"> cannot be instantiated; \"</span>\n                            <span class=\"sa\">f</span><span class=\"s2\">\"use </span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"o\">.</span><span class=\"n\">lower</span><span class=\"p\">()</span><span class=\"si\">}</span><span class=\"s2\">() instead\"</span><span class=\"p\">)</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">__orig_class__</span> <span class=\"o\">=</span> <span class=\"bp\">self</span>\n        <span class=\"k\">except</span> <span class=\"ne\">AttributeError</span><span class=\"p\">:</span>\n            <span class=\"k\">pass</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__mro_entries__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">bases</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">:</span>  <span class=\"c1\"># generic version of an ABC or built-in class</span>\n            <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n            <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">bases</span><span class=\"p\">:</span>\n                <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">)</span>\n            <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">bases</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">Generic</span><span class=\"p\">)</span>\n                       <span class=\"k\">for</span> <span class=\"n\">b</span> <span class=\"ow\">in</span> <span class=\"n\">bases</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">:]):</span>\n                <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Generic</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">Protocol</span> <span class=\"ow\">in</span> <span class=\"n\">bases</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"p\">()</span>\n            <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">bases</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n            <span class=\"k\">for</span> <span class=\"n\">b</span> <span class=\"ow\">in</span> <span class=\"n\">bases</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">:]:</span>\n                <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">b</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span> <span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__getattr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">):</span>\n        <span class=\"c1\"># We are careful for copy and pickle.</span>\n        <span class=\"c1\"># Also for simplicity we just don't relay all dunder names</span>\n        <span class=\"k\">if</span> <span class=\"s1\">'__origin__'</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"n\">_is_dunder</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">)</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">AttributeError</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__setattr__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">_is_dunder</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"s1\">'_name'</span><span class=\"p\">,</span> <span class=\"s1\">'_inst'</span><span class=\"p\">,</span> <span class=\"s1\">'_special'</span><span class=\"p\">):</span>\n            <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__setattr__</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__instancecheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"fm\">__subclasscheck__</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__subclasscheck__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">):</span>\n                <span class=\"k\">return</span> <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span><span class=\"p\">)</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Subscripted generics cannot be used with\"</span>\n                        <span class=\"s2\">\" class and instance checks\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__reduce__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span>\n\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">:</span>\n            <span class=\"n\">origin</span> <span class=\"o\">=</span> <span class=\"nb\">globals</span><span class=\"p\">()[</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span><span class=\"p\">]</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">origin</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">origin</span> <span class=\"ow\">is</span> <span class=\"n\">Callable</span> <span class=\"ow\">and</span>\n            <span class=\"ow\">not</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"bp\">Ellipsis</span><span class=\"p\">)):</span>\n            <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]),</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__args__</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n                <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">=</span> <span class=\"n\">args</span>\n        <span class=\"k\">return</span> <span class=\"n\">operator</span><span class=\"o\">.</span><span class=\"n\">getitem</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">origin</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_VariadicGenericAlias</span><span class=\"p\">(</span><span class=\"n\">_GenericAlias</span><span class=\"p\">,</span> <span class=\"n\">_root</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Same as _GenericAlias above but for variadic aliases. Currently,</span>\n<span class=\"sd\">    this is used only by special internal aliases: Tuple and Callable.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_name</span> <span class=\"o\">!=</span> <span class=\"s1\">'Callable'</span> <span class=\"ow\">or</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__getitem_inner__</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Callable must be used as \"</span>\n                            <span class=\"s2\">\"Callable[[arg, ...], result].\"</span><span class=\"p\">)</span>\n        <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">params</span>\n        <span class=\"k\">if</span> <span class=\"n\">args</span> <span class=\"ow\">is</span> <span class=\"bp\">Ellipsis</span><span class=\"p\">:</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"bp\">Ellipsis</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">):</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Callable[args, result]: args must be a list.\"</span>\n                                <span class=\"sa\">f</span><span class=\"s2\">\" Got </span><span class=\"si\">{</span><span class=\"n\">args</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">),</span> <span class=\"n\">result</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__getitem_inner__</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@_tp_cache</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__getitem_inner__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"nb\">tuple</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">params</span> <span class=\"o\">==</span> <span class=\"p\">():</span>\n                <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">((</span><span class=\"n\">_TypingEmpty</span><span class=\"p\">,))</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n                <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span> <span class=\"ow\">and</span> <span class=\"n\">params</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n                <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"Tuple[t, ...]: t must be a type.\"</span>\n                <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">msg</span><span class=\"p\">)</span>\n                <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">((</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">_TypingEllipsis</span><span class=\"p\">))</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"Tuple[t0, t1, ...]: each t must be a type.\"</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Callable</span> <span class=\"ow\">and</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n            <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">params</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"Callable[args, result]: result must be a type.\"</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">args</span> <span class=\"ow\">is</span> <span class=\"bp\">Ellipsis</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">((</span><span class=\"n\">_TypingEllipsis</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">))</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"Callable[[arg, ...], result]: each arg must be a type.\"</span>\n            <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">arg</span> <span class=\"ow\">in</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"n\">args</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">,)</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">copy_with</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Generic</span><span class=\"p\">:</span>\n    <span class=\"sd\">\"\"\"Abstract base class for generic types.</span>\n\n<span class=\"sd\">    A generic type is typically declared by inheriting from</span>\n<span class=\"sd\">    this class parameterized with one or more type variables.</span>\n<span class=\"sd\">    For example, a generic mapping type might be defined as::</span>\n\n<span class=\"sd\">      class Mapping(Generic[KT, VT]):</span>\n<span class=\"sd\">          def __getitem__(self, key: KT) -&gt; VT:</span>\n<span class=\"sd\">              ...</span>\n<span class=\"sd\">          # Etc.</span>\n\n<span class=\"sd\">    This class can then be used as follows::</span>\n\n<span class=\"sd\">      def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:</span>\n<span class=\"sd\">          try:</span>\n<span class=\"sd\">              return mapping[key]</span>\n<span class=\"sd\">          except KeyError:</span>\n<span class=\"sd\">              return default</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n    <span class=\"n\">_is_protocol</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">cls</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">Protocol</span><span class=\"p\">):</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Type </span><span class=\"si\">{</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"si\">}</span><span class=\"s2\"> cannot be instantiated; \"</span>\n                            <span class=\"s2\">\"it can be used only as a base class\"</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span> <span class=\"ow\">is</span> <span class=\"nb\">object</span><span class=\"o\">.</span><span class=\"fm\">__new__</span> <span class=\"ow\">and</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"fm\">__init__</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"nb\">object</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">:</span>\n            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">obj</span>\n\n    <span class=\"nd\">@_tp_cache</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__class_getitem__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">):</span>\n            <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">params</span> <span class=\"ow\">and</span> <span class=\"bp\">cls</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"n\">Tuple</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n                <span class=\"sa\">f</span><span class=\"s2\">\"Parameter list to </span><span class=\"si\">{</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span><span class=\"si\">}</span><span class=\"s2\">[...] cannot be empty\"</span><span class=\"p\">)</span>\n        <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"Parameters to generic types must be types.\"</span>\n        <span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"bp\">cls</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">Protocol</span><span class=\"p\">):</span>\n            <span class=\"c1\"># Generic and Protocol can only be subscripted with unique type variables.</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">TypeVar</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">):</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n                    <span class=\"sa\">f</span><span class=\"s2\">\"Parameters to </span><span class=\"si\">{</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"si\">}</span><span class=\"s2\">[...] must all be type variables\"</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">))</span> <span class=\"o\">!=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">):</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n                    <span class=\"sa\">f</span><span class=\"s2\">\"Parameters to </span><span class=\"si\">{</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"si\">}</span><span class=\"s2\">[...] must all be unique\"</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Subscripting a regular Generic subclass.</span>\n            <span class=\"n\">_check_generic</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__init_subclass__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">__init_subclass__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"n\">tvars</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">if</span> <span class=\"s1\">'__orig_bases__'</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">:</span>\n            <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">Generic</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__orig_bases__</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">Generic</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__bases__</span> <span class=\"ow\">and</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">!=</span> <span class=\"s1\">'Protocol'</span>\n        <span class=\"k\">if</span> <span class=\"n\">error</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Cannot inherit from plain Generic\"</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"s1\">'__orig_bases__'</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">:</span>\n            <span class=\"n\">tvars</span> <span class=\"o\">=</span> <span class=\"n\">_collect_type_vars</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__orig_bases__</span><span class=\"p\">)</span>\n            <span class=\"c1\"># Look for Generic[T1, ..., Tn].</span>\n            <span class=\"c1\"># If found, tvars must be a subset of it.</span>\n            <span class=\"c1\"># If not found, tvars is it.</span>\n            <span class=\"c1\"># Also check for and reject plain Generic,</span>\n            <span class=\"c1\"># and reject multiple Generic[...].</span>\n            <span class=\"n\">gvars</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n            <span class=\"k\">for</span> <span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__orig_bases__</span><span class=\"p\">:</span>\n                <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n                        <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">__origin__</span> <span class=\"ow\">is</span> <span class=\"n\">Generic</span><span class=\"p\">):</span>\n                    <span class=\"k\">if</span> <span class=\"n\">gvars</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span>\n                            <span class=\"s2\">\"Cannot inherit from Generic[...] multiple types.\"</span><span class=\"p\">)</span>\n                    <span class=\"n\">gvars</span> <span class=\"o\">=</span> <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span>\n            <span class=\"k\">if</span> <span class=\"n\">gvars</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">tvarset</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">tvars</span><span class=\"p\">)</span>\n                <span class=\"n\">gvarset</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">gvars</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">tvarset</span> <span class=\"o\">&lt;=</span> <span class=\"n\">gvarset</span><span class=\"p\">:</span>\n                    <span class=\"n\">s_vars</span> <span class=\"o\">=</span> <span class=\"s1\">', '</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">tvars</span> <span class=\"k\">if</span> <span class=\"n\">t</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">gvarset</span><span class=\"p\">)</span>\n                    <span class=\"n\">s_args</span> <span class=\"o\">=</span> <span class=\"s1\">', '</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">g</span> <span class=\"ow\">in</span> <span class=\"n\">gvars</span><span class=\"p\">)</span>\n                    <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Some type variables (</span><span class=\"si\">{</span><span class=\"n\">s_vars</span><span class=\"si\">}</span><span class=\"s2\">) are\"</span>\n                                    <span class=\"sa\">f</span><span class=\"s2\">\" not listed in Generic[</span><span class=\"si\">{</span><span class=\"n\">s_args</span><span class=\"si\">}</span><span class=\"s2\">]\"</span><span class=\"p\">)</span>\n                <span class=\"n\">tvars</span> <span class=\"o\">=</span> <span class=\"n\">gvars</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__parameters__</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">tvars</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_TypingEmpty</span><span class=\"p\">:</span>\n    <span class=\"sd\">\"\"\"Internal placeholder for () or []. Used by TupleMeta and CallableMeta</span>\n<span class=\"sd\">    to allow empty list/tuple in specific places, without allowing them</span>\n<span class=\"sd\">    to sneak in where prohibited.</span>\n<span class=\"sd\">    \"\"\"</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_TypingEllipsis</span><span class=\"p\">:</span>\n    <span class=\"sd\">\"\"\"Internal placeholder for ... (ellipsis).\"\"\"</span>\n\n\n<span class=\"n\">_TYPING_INTERNALS</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'__parameters__'</span><span class=\"p\">,</span> <span class=\"s1\">'__orig_bases__'</span><span class=\"p\">,</span>  <span class=\"s1\">'__orig_class__'</span><span class=\"p\">,</span>\n                     <span class=\"s1\">'_is_protocol'</span><span class=\"p\">,</span> <span class=\"s1\">'_is_runtime_protocol'</span><span class=\"p\">]</span>\n\n<span class=\"n\">_SPECIAL_NAMES</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'__abstractmethods__'</span><span class=\"p\">,</span> <span class=\"s1\">'__annotations__'</span><span class=\"p\">,</span> <span class=\"s1\">'__dict__'</span><span class=\"p\">,</span> <span class=\"s1\">'__doc__'</span><span class=\"p\">,</span>\n                  <span class=\"s1\">'__init__'</span><span class=\"p\">,</span> <span class=\"s1\">'__module__'</span><span class=\"p\">,</span> <span class=\"s1\">'__new__'</span><span class=\"p\">,</span> <span class=\"s1\">'__slots__'</span><span class=\"p\">,</span>\n                  <span class=\"s1\">'__subclasshook__'</span><span class=\"p\">,</span> <span class=\"s1\">'__weakref__'</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># These special attributes will be not collected as protocol members.</span>\n<span class=\"n\">EXCLUDED_ATTRIBUTES</span> <span class=\"o\">=</span> <span class=\"n\">_TYPING_INTERNALS</span> <span class=\"o\">+</span> <span class=\"n\">_SPECIAL_NAMES</span> <span class=\"o\">+</span> <span class=\"p\">[</span><span class=\"s1\">'_MutableMapping__marker'</span><span class=\"p\">]</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_get_protocol_attrs</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Collect protocol members from a protocol class objects.</span>\n\n<span class=\"sd\">    This includes names actually defined in the class dictionary, as well</span>\n<span class=\"sd\">    as names that appear in annotations. Special names (above) are skipped.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__mro__</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]:</span>  <span class=\"c1\"># without object</span>\n        <span class=\"k\">if</span> <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"s1\">'Protocol'</span><span class=\"p\">,</span> <span class=\"s1\">'Generic'</span><span class=\"p\">):</span>\n            <span class=\"k\">continue</span>\n        <span class=\"n\">annotations</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"s1\">'__annotations__'</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n        <span class=\"k\">for</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())</span> <span class=\"o\">+</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">annotations</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">()):</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">attr</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"s1\">'_abc_'</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">attr</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">EXCLUDED_ATTRIBUTES</span><span class=\"p\">:</span>\n                <span class=\"n\">attrs</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">attrs</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_is_callable_members_only</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n    <span class=\"c1\"># PEP 544 prohibits using issubclass() with protocols that have non-method members.</span>\n    <span class=\"k\">return</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"n\">callable</span><span class=\"p\">(</span><span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"n\">_get_protocol_attrs</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_no_init</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">_is_protocol</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">'Protocols cannot be instantiated'</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_allow_reckless_class_cheks</span><span class=\"p\">():</span>\n    <span class=\"sd\">\"\"\"Allow instnance and class checks for special stdlib modules.</span>\n\n<span class=\"sd\">    The abc and functools modules indiscriminately call isinstance() and</span>\n<span class=\"sd\">    issubclass() on the whole MRO of a user class, which may contain protocols.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">_getframe</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">f_globals</span><span class=\"p\">[</span><span class=\"s1\">'__name__'</span><span class=\"p\">]</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"s1\">'abc'</span><span class=\"p\">,</span> <span class=\"s1\">'functools'</span><span class=\"p\">]</span>\n    <span class=\"k\">except</span> <span class=\"p\">(</span><span class=\"ne\">AttributeError</span><span class=\"p\">,</span> <span class=\"ne\">ValueError</span><span class=\"p\">):</span>  <span class=\"c1\"># For platforms without _getframe().</span>\n        <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n\n<span class=\"n\">_PROTO_WHITELIST</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'collections.abc'</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n        <span class=\"s1\">'Callable'</span><span class=\"p\">,</span> <span class=\"s1\">'Awaitable'</span><span class=\"p\">,</span> <span class=\"s1\">'Iterable'</span><span class=\"p\">,</span> <span class=\"s1\">'Iterator'</span><span class=\"p\">,</span> <span class=\"s1\">'AsyncIterable'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'Hashable'</span><span class=\"p\">,</span> <span class=\"s1\">'Sized'</span><span class=\"p\">,</span> <span class=\"s1\">'Container'</span><span class=\"p\">,</span> <span class=\"s1\">'Collection'</span><span class=\"p\">,</span> <span class=\"s1\">'Reversible'</span><span class=\"p\">,</span>\n    <span class=\"p\">],</span>\n    <span class=\"s1\">'contextlib'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'AbstractContextManager'</span><span class=\"p\">,</span> <span class=\"s1\">'AbstractAsyncContextManager'</span><span class=\"p\">],</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_ProtocolMeta</span><span class=\"p\">(</span><span class=\"n\">ABCMeta</span><span class=\"p\">):</span>\n    <span class=\"c1\"># This metaclass is really unfortunate and exists only because of</span>\n    <span class=\"c1\"># the lack of __instancehook__.</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__instancecheck__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">instance</span><span class=\"p\">):</span>\n        <span class=\"c1\"># We need this method for situations where attributes are</span>\n        <span class=\"c1\"># assigned in __init__.</span>\n        <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"ow\">not</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"s1\">'_is_protocol'</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">)</span> <span class=\"ow\">or</span>\n                <span class=\"n\">_is_callable_members_only</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">))</span> <span class=\"ow\">and</span>\n                <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"o\">.</span><span class=\"vm\">__class__</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">)):</span>\n            <span class=\"k\">return</span> <span class=\"kc\">True</span>\n        <span class=\"k\">if</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_is_protocol</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n                    <span class=\"c1\"># All *methods* can be blocked by setting them to None.</span>\n                    <span class=\"p\">(</span><span class=\"ow\">not</span> <span class=\"n\">callable</span><span class=\"p\">(</span><span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">))</span> <span class=\"ow\">or</span>\n                     <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"n\">attr</span><span class=\"p\">)</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n                    <span class=\"k\">for</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"n\">_get_protocol_attrs</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">)):</span>\n                <span class=\"k\">return</span> <span class=\"kc\">True</span>\n        <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__instancecheck__</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Protocol</span><span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">,</span> <span class=\"n\">metaclass</span><span class=\"o\">=</span><span class=\"n\">_ProtocolMeta</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Base class for protocol classes.</span>\n\n<span class=\"sd\">    Protocol classes are defined as::</span>\n\n<span class=\"sd\">        class Proto(Protocol):</span>\n<span class=\"sd\">            def meth(self) -&gt; int:</span>\n<span class=\"sd\">                ...</span>\n\n<span class=\"sd\">    Such classes are primarily used with static type checkers that recognize</span>\n<span class=\"sd\">    structural subtyping (static duck-typing), for example::</span>\n\n<span class=\"sd\">        class C:</span>\n<span class=\"sd\">            def meth(self) -&gt; int:</span>\n<span class=\"sd\">                return 0</span>\n\n<span class=\"sd\">        def func(x: Proto) -&gt; int:</span>\n<span class=\"sd\">            return x.meth()</span>\n\n<span class=\"sd\">        func(C())  # Passes static type check</span>\n\n<span class=\"sd\">    See PEP 544 for details. Protocol classes decorated with</span>\n<span class=\"sd\">    @typing.runtime_checkable act as simple-minded runtime protocols that check</span>\n<span class=\"sd\">    only the presence of given attributes, ignoring their type signatures.</span>\n<span class=\"sd\">    Protocol classes can be generic, they are defined as::</span>\n\n<span class=\"sd\">        class GenProto(Protocol[T]):</span>\n<span class=\"sd\">            def meth(self) -&gt; T:</span>\n<span class=\"sd\">                ...</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n    <span class=\"n\">_is_protocol</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"n\">_is_runtime_protocol</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__init_subclass__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">__init_subclass__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Determine if this is a protocol or a concrete subclass.</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'_is_protocol'</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">):</span>\n            <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_is_protocol</span> <span class=\"o\">=</span> <span class=\"nb\">any</span><span class=\"p\">(</span><span class=\"n\">b</span> <span class=\"ow\">is</span> <span class=\"n\">Protocol</span> <span class=\"k\">for</span> <span class=\"n\">b</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__bases__</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Set (or override) the protocol subclass hook.</span>\n        <span class=\"k\">def</span> <span class=\"nf\">_proto_hook</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'_is_protocol'</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">):</span>\n                <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n\n            <span class=\"c1\"># First, perform various sanity checks.</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"s1\">'_is_runtime_protocol'</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">_allow_reckless_class_cheks</span><span class=\"p\">():</span>\n                    <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Instance and class checks can only be used with\"</span>\n                                <span class=\"s2\">\" @runtime_checkable protocols\"</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">_is_callable_members_only</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n                <span class=\"k\">if</span> <span class=\"n\">_allow_reckless_class_cheks</span><span class=\"p\">():</span>\n                    <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Protocols with non-method members\"</span>\n                                <span class=\"s2\">\" don't support issubclass()\"</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n                <span class=\"c1\"># Same error message as for issubclass(1, int).</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">'issubclass() arg 1 must be a class'</span><span class=\"p\">)</span>\n\n            <span class=\"c1\"># Second, perform the actual structural compatibility check.</span>\n            <span class=\"k\">for</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"n\">_get_protocol_attrs</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n                <span class=\"k\">for</span> <span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"vm\">__mro__</span><span class=\"p\">:</span>\n                    <span class=\"c1\"># Check if the members appears in the class dictionary...</span>\n                    <span class=\"k\">if</span> <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">:</span>\n                        <span class=\"k\">if</span> <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">[</span><span class=\"n\">attr</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                            <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n                        <span class=\"k\">break</span>\n\n                    <span class=\"c1\"># ...or in annotations, if it is a sub-protocol.</span>\n                    <span class=\"n\">annotations</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"s1\">'__annotations__'</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">annotations</span><span class=\"p\">,</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Mapping</span><span class=\"p\">)</span> <span class=\"ow\">and</span>\n                            <span class=\"n\">attr</span> <span class=\"ow\">in</span> <span class=\"n\">annotations</span> <span class=\"ow\">and</span>\n                            <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"n\">other</span><span class=\"p\">,</span> <span class=\"n\">Generic</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"n\">_is_protocol</span><span class=\"p\">):</span>\n                        <span class=\"k\">break</span>\n                <span class=\"k\">else</span><span class=\"p\">:</span>\n                    <span class=\"k\">return</span> <span class=\"bp\">NotImplemented</span>\n            <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n        <span class=\"k\">if</span> <span class=\"s1\">'__subclasshook__'</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"p\">:</span>\n            <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">__subclasshook__</span> <span class=\"o\">=</span> <span class=\"n\">_proto_hook</span>\n\n        <span class=\"c1\"># We have nothing more to do for non-protocols...</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_is_protocol</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span>\n\n        <span class=\"c1\"># ... otherwise check consistency of bases, and prohibit instantiation.</span>\n        <span class=\"k\">for</span> <span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"vm\">__bases__</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"p\">(</span><span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">,</span> <span class=\"n\">Generic</span><span class=\"p\">)</span> <span class=\"ow\">or</span>\n                    <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__module__</span> <span class=\"ow\">in</span> <span class=\"n\">_PROTO_WHITELIST</span> <span class=\"ow\">and</span>\n                    <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"ow\">in</span> <span class=\"n\">_PROTO_WHITELIST</span><span class=\"p\">[</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__module__</span><span class=\"p\">]</span> <span class=\"ow\">or</span>\n                    <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">,</span> <span class=\"n\">Generic</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">_is_protocol</span><span class=\"p\">):</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">'Protocols can only inherit from other'</span>\n                                <span class=\"s1\">' protocols, got </span><span class=\"si\">%r</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"n\">base</span><span class=\"p\">)</span>\n        <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"fm\">__init__</span> <span class=\"o\">=</span> <span class=\"n\">_no_init</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">runtime_checkable</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Mark a protocol class as a runtime protocol.</span>\n\n<span class=\"sd\">    Such protocol can be used with isinstance() and issubclass().</span>\n<span class=\"sd\">    Raise TypeError if applied to a non-protocol class.</span>\n<span class=\"sd\">    This allows a simple-minded structural check very similar to</span>\n<span class=\"sd\">    one trick ponies in collections.abc such as Iterable.</span>\n<span class=\"sd\">    For example::</span>\n\n<span class=\"sd\">        @runtime_checkable</span>\n<span class=\"sd\">        class Closable(Protocol):</span>\n<span class=\"sd\">            def close(self): ...</span>\n\n<span class=\"sd\">        assert isinstance(open('/some/file'), Closable)</span>\n\n<span class=\"sd\">    Warning: this will check only the presence of the required methods,</span>\n<span class=\"sd\">    not their type signatures!</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">issubclass</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">Generic</span><span class=\"p\">)</span> <span class=\"ow\">or</span> <span class=\"ow\">not</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_is_protocol</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">'@runtime_checkable can be only applied to protocol classes,'</span>\n                        <span class=\"s1\">' got </span><span class=\"si\">%r</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"bp\">cls</span><span class=\"p\">)</span>\n    <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">_is_runtime_protocol</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"k\">return</span> <span class=\"bp\">cls</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">cast</span><span class=\"p\">(</span><span class=\"n\">typ</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Cast a value to a type.</span>\n\n<span class=\"sd\">    This returns the value unchanged.  To the type checker this</span>\n<span class=\"sd\">    signals that the return value has the designated type, but at</span>\n<span class=\"sd\">    runtime we intentionally don't check anything (we want this</span>\n<span class=\"sd\">    to be as fast as possible).</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">return</span> <span class=\"n\">val</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_get_defaults</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Internal helper to extract the default arguments, by name.\"\"\"</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"o\">.</span><span class=\"vm\">__code__</span>\n    <span class=\"k\">except</span> <span class=\"ne\">AttributeError</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Some built-in functions don't have __code__, __defaults__, etc.</span>\n        <span class=\"k\">return</span> <span class=\"p\">{}</span>\n    <span class=\"n\">pos_count</span> <span class=\"o\">=</span> <span class=\"n\">code</span><span class=\"o\">.</span><span class=\"n\">co_argcount</span>\n    <span class=\"n\">arg_names</span> <span class=\"o\">=</span> <span class=\"n\">code</span><span class=\"o\">.</span><span class=\"n\">co_varnames</span>\n    <span class=\"n\">arg_names</span> <span class=\"o\">=</span> <span class=\"n\">arg_names</span><span class=\"p\">[:</span><span class=\"n\">pos_count</span><span class=\"p\">]</span>\n    <span class=\"n\">defaults</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"o\">.</span><span class=\"vm\">__defaults__</span> <span class=\"ow\">or</span> <span class=\"p\">()</span>\n    <span class=\"n\">kwdefaults</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"o\">.</span><span class=\"vm\">__kwdefaults__</span>\n    <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">kwdefaults</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">kwdefaults</span> <span class=\"k\">else</span> <span class=\"p\">{}</span>\n    <span class=\"n\">pos_offset</span> <span class=\"o\">=</span> <span class=\"n\">pos_count</span> <span class=\"o\">-</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">defaults</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"nb\">zip</span><span class=\"p\">(</span><span class=\"n\">arg_names</span><span class=\"p\">[</span><span class=\"n\">pos_offset</span><span class=\"p\">:],</span> <span class=\"n\">defaults</span><span class=\"p\">):</span>\n        <span class=\"k\">assert</span> <span class=\"n\">name</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">res</span>\n        <span class=\"n\">res</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n    <span class=\"k\">return</span> <span class=\"n\">res</span>\n\n\n<span class=\"n\">_allowed_types</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">FunctionType</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">BuiltinFunctionType</span><span class=\"p\">,</span>\n                  <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">MethodType</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">ModuleType</span><span class=\"p\">,</span>\n                  <span class=\"n\">WrapperDescriptorType</span><span class=\"p\">,</span> <span class=\"n\">MethodWrapperType</span><span class=\"p\">,</span> <span class=\"n\">MethodDescriptorType</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">get_type_hints</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Return type hints for an object.</span>\n\n<span class=\"sd\">    This is often the same as obj.__annotations__, but it handles</span>\n<span class=\"sd\">    forward references encoded as string literals, and if necessary</span>\n<span class=\"sd\">    adds Optional[t] if a default value equal to None is set.</span>\n\n<span class=\"sd\">    The argument may be a module, class, method, or function. The annotations</span>\n<span class=\"sd\">    are returned as a dictionary. For classes, annotations include also</span>\n<span class=\"sd\">    inherited members.</span>\n\n<span class=\"sd\">    TypeError is raised if the argument is not of a type that can contain</span>\n<span class=\"sd\">    annotations, and an empty dictionary is returned if no annotations are</span>\n<span class=\"sd\">    present.</span>\n\n<span class=\"sd\">    BEWARE -- the behavior of globalns and localns is counterintuitive</span>\n<span class=\"sd\">    (unless you are familiar with how eval() and exec() work).  The</span>\n<span class=\"sd\">    search order is locals first, then globals.</span>\n\n<span class=\"sd\">    - If no dict arguments are passed, an attempt is made to use the</span>\n<span class=\"sd\">      globals from obj (or the respective module's globals for classes),</span>\n<span class=\"sd\">      and these are also used as the locals.  If the object does not appear</span>\n<span class=\"sd\">      to have globals, an empty dictionary is used.</span>\n\n<span class=\"sd\">    - If one dict argument is passed, it is used for both globals and</span>\n<span class=\"sd\">      locals.</span>\n\n<span class=\"sd\">    - If two dict arguments are passed, they specify globals and</span>\n<span class=\"sd\">      locals, respectively.</span>\n<span class=\"sd\">    \"\"\"</span>\n\n    <span class=\"k\">if</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"s1\">'__no_type_check__'</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"p\">{}</span>\n    <span class=\"c1\"># Classes require a special treatment.</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n        <span class=\"n\">hints</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"nb\">reversed</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__mro__</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">globalns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                <span class=\"n\">base_globals</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"p\">[</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__module__</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">base_globals</span> <span class=\"o\">=</span> <span class=\"n\">globalns</span>\n            <span class=\"n\">ann</span> <span class=\"o\">=</span> <span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'__annotations__'</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n            <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">ann</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n                <span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">):</span>\n                    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">is_argument</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n                <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">_eval_type</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">base_globals</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">)</span>\n                <span class=\"n\">hints</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n        <span class=\"k\">return</span> <span class=\"n\">hints</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">globalns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">ModuleType</span><span class=\"p\">):</span>\n            <span class=\"n\">globalns</span> <span class=\"o\">=</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">nsobj</span> <span class=\"o\">=</span> <span class=\"n\">obj</span>\n            <span class=\"c1\"># Find globalns for the unwrapped object.</span>\n            <span class=\"k\">while</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">nsobj</span><span class=\"p\">,</span> <span class=\"s1\">'__wrapped__'</span><span class=\"p\">):</span>\n                <span class=\"n\">nsobj</span> <span class=\"o\">=</span> <span class=\"n\">nsobj</span><span class=\"o\">.</span><span class=\"n\">__wrapped__</span>\n            <span class=\"n\">globalns</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">nsobj</span><span class=\"p\">,</span> <span class=\"s1\">'__globals__'</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n        <span class=\"k\">if</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">localns</span> <span class=\"o\">=</span> <span class=\"n\">globalns</span>\n    <span class=\"k\">elif</span> <span class=\"n\">localns</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">localns</span> <span class=\"o\">=</span> <span class=\"n\">globalns</span>\n    <span class=\"n\">hints</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"s1\">'__annotations__'</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">hints</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Return empty annotations for something that _could_ have them.</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">_allowed_types</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"p\">{}</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"si\">{!r}</span><span class=\"s1\"> is not a module, class, method, '</span>\n                            <span class=\"s1\">'or function.'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">))</span>\n    <span class=\"n\">defaults</span> <span class=\"o\">=</span> <span class=\"n\">_get_defaults</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n    <span class=\"n\">hints</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">hints</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">hints</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n        <span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">):</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">ForwardRef</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">_eval_type</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">globalns</span><span class=\"p\">,</span> <span class=\"n\">localns</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">defaults</span> <span class=\"ow\">and</span> <span class=\"n\">defaults</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">value</span><span class=\"p\">]</span>\n        <span class=\"n\">hints</span><span class=\"p\">[</span><span class=\"n\">name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n    <span class=\"k\">return</span> <span class=\"n\">hints</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">get_origin</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Get the unsubscripted version of a type.</span>\n\n<span class=\"sd\">    This supports generic types, Callable, Tuple, Union, Literal, Final and ClassVar.</span>\n<span class=\"sd\">    Return None for unsupported types. Examples::</span>\n\n<span class=\"sd\">        get_origin(Literal[42]) is Literal</span>\n<span class=\"sd\">        get_origin(int) is None</span>\n<span class=\"sd\">        get_origin(ClassVar[int]) is ClassVar</span>\n<span class=\"sd\">        get_origin(Generic) is Generic</span>\n<span class=\"sd\">        get_origin(Generic[T]) is Generic</span>\n<span class=\"sd\">        get_origin(Union[T, int]) is Union</span>\n<span class=\"sd\">        get_origin(List[Tuple[T, T]][int]) == list</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">__origin__</span>\n    <span class=\"k\">if</span> <span class=\"n\">tp</span> <span class=\"ow\">is</span> <span class=\"n\">Generic</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">Generic</span>\n    <span class=\"k\">return</span> <span class=\"kc\">None</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">get_args</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Get type arguments with all substitutions performed.</span>\n\n<span class=\"sd\">    For unions, basic simplifications used by Union constructor are performed.</span>\n<span class=\"sd\">    Examples::</span>\n<span class=\"sd\">        get_args(Dict[str, int]) == (str, int)</span>\n<span class=\"sd\">        get_args(int) == ()</span>\n<span class=\"sd\">        get_args(Union[int, Union[T, int], str][int]) == (int, str)</span>\n<span class=\"sd\">        get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])</span>\n<span class=\"sd\">        get_args(Callable[[], T][int]) == ([], int)</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">,</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">)</span> <span class=\"ow\">and</span> <span class=\"ow\">not</span> <span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">_special</span><span class=\"p\">:</span>\n        <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">tp</span><span class=\"o\">.</span><span class=\"n\">__args__</span>\n        <span class=\"k\">if</span> <span class=\"n\">get_origin</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">)</span> <span class=\"ow\">is</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Callable</span> <span class=\"ow\">and</span> <span class=\"n\">res</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">Ellipsis</span><span class=\"p\">:</span>\n            <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]),</span> <span class=\"n\">res</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span>\n    <span class=\"k\">return</span> <span class=\"p\">()</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">no_type_check</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Decorator to indicate that annotations are not type hints.</span>\n\n<span class=\"sd\">    The argument must be a class or function; if it is a class, it</span>\n<span class=\"sd\">    applies recursively to all methods and classes defined in that class</span>\n<span class=\"sd\">    (but not to methods defined in its superclasses or subclasses).</span>\n\n<span class=\"sd\">    This mutates the function(s) or class(es) in place.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n        <span class=\"n\">arg_attrs</span> <span class=\"o\">=</span> <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n        <span class=\"k\">for</span> <span class=\"n\">attr</span><span class=\"p\">,</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n            <span class=\"k\">if</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"vm\">__bases__</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,):</span>\n                <span class=\"n\">arg_attrs</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"n\">attr</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">obj</span> <span class=\"ow\">in</span> <span class=\"n\">arg_attrs</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">():</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">FunctionType</span><span class=\"p\">):</span>\n                <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">__no_type_check__</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n                <span class=\"n\">no_type_check</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">arg</span><span class=\"o\">.</span><span class=\"n\">__no_type_check__</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"k\">except</span> <span class=\"ne\">TypeError</span><span class=\"p\">:</span>  <span class=\"c1\"># built-in classes</span>\n        <span class=\"k\">pass</span>\n    <span class=\"k\">return</span> <span class=\"n\">arg</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">no_type_check_decorator</span><span class=\"p\">(</span><span class=\"n\">decorator</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Decorator to give another decorator the @no_type_check effect.</span>\n\n<span class=\"sd\">    This wraps the decorator with something that wraps the decorated</span>\n<span class=\"sd\">    function in @no_type_check.</span>\n<span class=\"sd\">    \"\"\"</span>\n\n    <span class=\"nd\">@functools</span><span class=\"o\">.</span><span class=\"n\">wraps</span><span class=\"p\">(</span><span class=\"n\">decorator</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">wrapped_decorator</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n        <span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">decorator</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">)</span>\n        <span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"n\">no_type_check</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">func</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">wrapped_decorator</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_overload_dummy</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwds</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Helper for @overload to raise when called.\"\"\"</span>\n    <span class=\"k\">raise</span> <span class=\"ne\">NotImplementedError</span><span class=\"p\">(</span>\n        <span class=\"s2\">\"You should not call an overloaded function. \"</span>\n        <span class=\"s2\">\"A series of @overload-decorated functions \"</span>\n        <span class=\"s2\">\"outside a stub module should always be followed \"</span>\n        <span class=\"s2\">\"by an implementation that is not @overload-ed.\"</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">overload</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Decorator for overloaded functions/methods.</span>\n\n<span class=\"sd\">    In a stub file, place two or more stub definitions for the same</span>\n<span class=\"sd\">    function in a row, each decorated with @overload.  For example:</span>\n\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: None) -&gt; None: ...</span>\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: bytes) -&gt; bytes: ...</span>\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: str) -&gt; bytes: ...</span>\n\n<span class=\"sd\">    In a non-stub file (i.e. a regular .py file), do the same but</span>\n<span class=\"sd\">    follow it with an implementation.  The implementation should *not*</span>\n<span class=\"sd\">    be decorated with @overload.  For example:</span>\n\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: None) -&gt; None: ...</span>\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: bytes) -&gt; bytes: ...</span>\n<span class=\"sd\">      @overload</span>\n<span class=\"sd\">      def utf8(value: str) -&gt; bytes: ...</span>\n<span class=\"sd\">      def utf8(value):</span>\n<span class=\"sd\">          # implementation goes here</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">return</span> <span class=\"n\">_overload_dummy</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">final</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"A decorator to indicate final methods and final classes.</span>\n\n<span class=\"sd\">    Use this decorator to indicate to type checkers that the decorated</span>\n<span class=\"sd\">    method cannot be overridden, and decorated class cannot be subclassed.</span>\n<span class=\"sd\">    For example:</span>\n\n<span class=\"sd\">      class Base:</span>\n<span class=\"sd\">          @final</span>\n<span class=\"sd\">          def done(self) -&gt; None:</span>\n<span class=\"sd\">              ...</span>\n<span class=\"sd\">      class Sub(Base):</span>\n<span class=\"sd\">          def done(self) -&gt; None:  # Error reported by type checker</span>\n<span class=\"sd\">                ...</span>\n\n<span class=\"sd\">      @final</span>\n<span class=\"sd\">      class Leaf:</span>\n<span class=\"sd\">          ...</span>\n<span class=\"sd\">      class Other(Leaf):  # Error reported by type checker</span>\n<span class=\"sd\">          ...</span>\n\n<span class=\"sd\">    There is no runtime checking of these properties.</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">return</span> <span class=\"n\">f</span>\n\n\n<span class=\"c1\"># Some unconstrained type variables.  These are used by the container types.</span>\n<span class=\"c1\"># (These are not for export.)</span>\n<span class=\"n\">T</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'T'</span><span class=\"p\">)</span>  <span class=\"c1\"># Any type.</span>\n<span class=\"n\">KT</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'KT'</span><span class=\"p\">)</span>  <span class=\"c1\"># Key type.</span>\n<span class=\"n\">VT</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'VT'</span><span class=\"p\">)</span>  <span class=\"c1\"># Value type.</span>\n<span class=\"n\">T_co</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'T_co'</span><span class=\"p\">,</span> <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># Any type covariant containers.</span>\n<span class=\"n\">V_co</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'V_co'</span><span class=\"p\">,</span> <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># Any type covariant containers.</span>\n<span class=\"n\">VT_co</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'VT_co'</span><span class=\"p\">,</span> <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># Value type covariant containers.</span>\n<span class=\"n\">T_contra</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'T_contra'</span><span class=\"p\">,</span> <span class=\"n\">contravariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># Ditto contravariant.</span>\n<span class=\"c1\"># Internal type variable used for Type[].</span>\n<span class=\"n\">CT_co</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'CT_co'</span><span class=\"p\">,</span> <span class=\"n\">covariant</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">bound</span><span class=\"o\">=</span><span class=\"nb\">type</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># A useful type variable with constraints.  This represents string types.</span>\n<span class=\"c1\"># (This one *is* for export!)</span>\n<span class=\"n\">AnyStr</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'AnyStr'</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># Various ABCs mimicking those in collections.abc.</span>\n<span class=\"k\">def</span> <span class=\"nf\">_alias</span><span class=\"p\">(</span><span class=\"n\">origin</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">_GenericAlias</span><span class=\"p\">(</span><span class=\"n\">origin</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">special</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"n\">inst</span><span class=\"p\">)</span>\n\n<span class=\"n\">Hashable</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Hashable</span><span class=\"p\">,</span> <span class=\"p\">())</span>  <span class=\"c1\"># Not generic.</span>\n<span class=\"n\">Awaitable</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Awaitable</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Coroutine</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Coroutine</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">T_co</span><span class=\"p\">,</span> <span class=\"n\">T_contra</span><span class=\"p\">,</span> <span class=\"n\">V_co</span><span class=\"p\">))</span>\n<span class=\"n\">AsyncIterable</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">AsyncIterable</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">AsyncIterator</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">AsyncIterator</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Iterable</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Iterable</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Iterator</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Iterator</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Reversible</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Reversible</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Sized</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Sized</span><span class=\"p\">,</span> <span class=\"p\">())</span>  <span class=\"c1\"># Not generic.</span>\n<span class=\"n\">Container</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Container</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Collection</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Collection</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"n\">_VariadicGenericAlias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Callable</span><span class=\"p\">,</span> <span class=\"p\">(),</span> <span class=\"n\">special</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">Callable</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span> <span class=\"o\">=</span> \\\n    <span class=\"sd\">\"\"\"Callable type; Callable[[int], str] is a function of (int) -&gt; str.</span>\n\n<span class=\"sd\">    The subscription syntax must always be used with exactly two</span>\n<span class=\"sd\">    values: the argument list and the return type.  The argument list</span>\n<span class=\"sd\">    must be a list of types or ellipsis; the return type must be a single type.</span>\n\n<span class=\"sd\">    There is no syntax to indicate optional or keyword arguments,</span>\n<span class=\"sd\">    such function types are rarely used as callback types.</span>\n<span class=\"sd\">    \"\"\"</span>\n<span class=\"n\">AbstractSet</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Set</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">MutableSet</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">MutableSet</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"c1\"># NOTE: Mapping is only covariant in the value type.</span>\n<span class=\"n\">Mapping</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Mapping</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT_co</span><span class=\"p\">))</span>\n<span class=\"n\">MutableMapping</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">MutableMapping</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">))</span>\n<span class=\"n\">Sequence</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Sequence</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">MutableSequence</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">MutableSequence</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"n\">ByteString</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">ByteString</span><span class=\"p\">,</span> <span class=\"p\">())</span>  <span class=\"c1\"># Not generic</span>\n<span class=\"n\">Tuple</span> <span class=\"o\">=</span> <span class=\"n\">_VariadicGenericAlias</span><span class=\"p\">(</span><span class=\"nb\">tuple</span><span class=\"p\">,</span> <span class=\"p\">(),</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">special</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">Tuple</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span> <span class=\"o\">=</span> \\\n    <span class=\"sd\">\"\"\"Tuple type; Tuple[X, Y] is the cross-product type of X and Y.</span>\n\n<span class=\"sd\">    Example: Tuple[T1, T2] is a tuple of two elements corresponding</span>\n<span class=\"sd\">    to type variables T1 and T2.  Tuple[int, float, str] is a tuple</span>\n<span class=\"sd\">    of an int, a float and a string.</span>\n\n<span class=\"sd\">    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].</span>\n<span class=\"sd\">    \"\"\"</span>\n<span class=\"n\">List</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">Deque</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">deque</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"n\">Set</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">FrozenSet</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">frozenset</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">MappingView</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">MappingView</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">KeysView</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">KeysView</span><span class=\"p\">,</span> <span class=\"n\">KT</span><span class=\"p\">)</span>\n<span class=\"n\">ItemsView</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">ItemsView</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT_co</span><span class=\"p\">))</span>\n<span class=\"n\">ValuesView</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">ValuesView</span><span class=\"p\">,</span> <span class=\"n\">VT_co</span><span class=\"p\">)</span>\n<span class=\"n\">ContextManager</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">contextlib</span><span class=\"o\">.</span><span class=\"n\">AbstractContextManager</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">AsyncContextManager</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">contextlib</span><span class=\"o\">.</span><span class=\"n\">AbstractAsyncContextManager</span><span class=\"p\">,</span> <span class=\"n\">T_co</span><span class=\"p\">)</span>\n<span class=\"n\">Dict</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">),</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">DefaultDict</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">defaultdict</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">))</span>\n<span class=\"n\">OrderedDict</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">OrderedDict</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">))</span>\n<span class=\"n\">Counter</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">Counter</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"n\">ChainMap</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">ChainMap</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">KT</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">))</span>\n<span class=\"n\">Generator</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">Generator</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">T_co</span><span class=\"p\">,</span> <span class=\"n\">T_contra</span><span class=\"p\">,</span> <span class=\"n\">V_co</span><span class=\"p\">))</span>\n<span class=\"n\">AsyncGenerator</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">abc</span><span class=\"o\">.</span><span class=\"n\">AsyncGenerator</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">T_co</span><span class=\"p\">,</span> <span class=\"n\">T_contra</span><span class=\"p\">))</span>\n<span class=\"n\">Type</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">,</span> <span class=\"n\">CT_co</span><span class=\"p\">,</span> <span class=\"n\">inst</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">Type</span><span class=\"o\">.</span><span class=\"vm\">__doc__</span> <span class=\"o\">=</span> \\\n    <span class=\"sd\">\"\"\"A special construct usable to annotate class objects.</span>\n\n<span class=\"sd\">    For example, suppose we have the following classes::</span>\n\n<span class=\"sd\">      class User: ...  # Abstract base for User classes</span>\n<span class=\"sd\">      class BasicUser(User): ...</span>\n<span class=\"sd\">      class ProUser(User): ...</span>\n<span class=\"sd\">      class TeamUser(User): ...</span>\n\n<span class=\"sd\">    And a function that takes a class argument that's a subclass of</span>\n<span class=\"sd\">    User and returns an instance of the corresponding class::</span>\n\n<span class=\"sd\">      U = TypeVar('U', bound=User)</span>\n<span class=\"sd\">      def new_user(user_class: Type[U]) -&gt; U:</span>\n<span class=\"sd\">          user = user_class()</span>\n<span class=\"sd\">          # (Here we could write the user object to a database)</span>\n<span class=\"sd\">          return user</span>\n\n<span class=\"sd\">      joe = new_user(BasicUser)</span>\n\n<span class=\"sd\">    At this point the type checker knows that joe has type BasicUser.</span>\n<span class=\"sd\">    \"\"\"</span>\n\n\n<span class=\"nd\">@runtime_checkable</span>\n<span class=\"k\">class</span> <span class=\"nc\">SupportsInt</span><span class=\"p\">(</span><span class=\"n\">Protocol</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"An ABC with one abstract method __int__.\"\"\"</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__int__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"nd\">@runtime_checkable</span>\n<span class=\"k\">class</span> <span class=\"nc\">SupportsFloat</span><span class=\"p\">(</span><span class=\"n\">Protocol</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"An ABC with one abstract method __float__.\"\"\"</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__float__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">float</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"nd\">@runtime_checkable</span>\n<span class=\"k\">class</span> <span class=\"nc\">SupportsComplex</span><span class=\"p\">(</span><span class=\"n\">Protocol</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"An ABC with one abstract method __complex__.\"\"\"</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__complex__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">complex</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"nd\">@runtime_checkable</span>\n<span class=\"k\">class</span> <span class=\"nc\">SupportsBytes</span><span class=\"p\">(</span><span class=\"n\">Protocol</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"An ABC with one abstract method __bytes__.\"\"\"</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__bytes__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bytes</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"nd\">@runtime_checkable</span>\n<span class=\"k\">class</span> <span class=\"nc\">SupportsIndex</span><span class=\"p\">(</span><span class=\"n\">Protocol</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"An ABC with one abstract method __index__.\"\"\"</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__index__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"nd\">@runtime_checkable</span>\n<span class=\"k\">class</span> <span class=\"nc\">SupportsAbs</span><span class=\"p\">(</span><span class=\"n\">Protocol</span><span class=\"p\">[</span><span class=\"n\">T_co</span><span class=\"p\">]):</span>\n    <span class=\"sd\">\"\"\"An ABC with one abstract method __abs__ that is covariant in its return type.\"\"\"</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__abs__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">T_co</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"nd\">@runtime_checkable</span>\n<span class=\"k\">class</span> <span class=\"nc\">SupportsRound</span><span class=\"p\">(</span><span class=\"n\">Protocol</span><span class=\"p\">[</span><span class=\"n\">T_co</span><span class=\"p\">]):</span>\n    <span class=\"sd\">\"\"\"An ABC with one abstract method __round__ that is covariant in its return type.\"\"\"</span>\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__round__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">ndigits</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">T_co</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_make_nmtuple</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"p\">):</span>\n    <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"NamedTuple('Name', [(f0, t0), (f1, t1), ...]); each t must be a type\"</span>\n    <span class=\"n\">types</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">]</span>\n    <span class=\"n\">nm_tpl</span> <span class=\"o\">=</span> <span class=\"n\">collections</span><span class=\"o\">.</span><span class=\"n\">namedtuple</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">n</span> <span class=\"k\">for</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">])</span>\n    <span class=\"c1\"># Prior to PEP 526, only _field_types attribute was assigned.</span>\n    <span class=\"c1\"># Now __annotations__ are used and _field_types is deprecated (remove in 3.9)</span>\n    <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"vm\">__annotations__</span> <span class=\"o\">=</span> <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"n\">_field_types</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">types</span><span class=\"p\">)</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"vm\">__module__</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">_getframe</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">f_globals</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'__name__'</span><span class=\"p\">,</span> <span class=\"s1\">'__main__'</span><span class=\"p\">)</span>\n    <span class=\"k\">except</span> <span class=\"p\">(</span><span class=\"ne\">AttributeError</span><span class=\"p\">,</span> <span class=\"ne\">ValueError</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n    <span class=\"k\">return</span> <span class=\"n\">nm_tpl</span>\n\n\n<span class=\"c1\"># attributes prohibited to set in NamedTuple class syntax</span>\n<span class=\"n\">_prohibited</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'__new__'</span><span class=\"p\">,</span> <span class=\"s1\">'__init__'</span><span class=\"p\">,</span> <span class=\"s1\">'__slots__'</span><span class=\"p\">,</span> <span class=\"s1\">'__getnewargs__'</span><span class=\"p\">,</span>\n               <span class=\"s1\">'_fields'</span><span class=\"p\">,</span> <span class=\"s1\">'_field_defaults'</span><span class=\"p\">,</span> <span class=\"s1\">'_field_types'</span><span class=\"p\">,</span>\n               <span class=\"s1\">'_make'</span><span class=\"p\">,</span> <span class=\"s1\">'_replace'</span><span class=\"p\">,</span> <span class=\"s1\">'_asdict'</span><span class=\"p\">,</span> <span class=\"s1\">'_source'</span><span class=\"p\">)</span>\n\n<span class=\"n\">_special</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'__module__'</span><span class=\"p\">,</span> <span class=\"s1\">'__name__'</span><span class=\"p\">,</span> <span class=\"s1\">'__annotations__'</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">NamedTupleMeta</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">bases</span><span class=\"p\">,</span> <span class=\"n\">ns</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">ns</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'_root'</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">bases</span><span class=\"p\">,</span> <span class=\"n\">ns</span><span class=\"p\">)</span>\n        <span class=\"n\">types</span> <span class=\"o\">=</span> <span class=\"n\">ns</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'__annotations__'</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n        <span class=\"n\">nm_tpl</span> <span class=\"o\">=</span> <span class=\"n\">_make_nmtuple</span><span class=\"p\">(</span><span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">types</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">())</span>\n        <span class=\"n\">defaults</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"n\">defaults_dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">field_name</span> <span class=\"ow\">in</span> <span class=\"n\">types</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">field_name</span> <span class=\"ow\">in</span> <span class=\"n\">ns</span><span class=\"p\">:</span>\n                <span class=\"n\">default_value</span> <span class=\"o\">=</span> <span class=\"n\">ns</span><span class=\"p\">[</span><span class=\"n\">field_name</span><span class=\"p\">]</span>\n                <span class=\"n\">defaults</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">default_value</span><span class=\"p\">)</span>\n                <span class=\"n\">defaults_dict</span><span class=\"p\">[</span><span class=\"n\">field_name</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">default_value</span>\n            <span class=\"k\">elif</span> <span class=\"n\">defaults</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Non-default namedtuple field </span><span class=\"si\">{field_name}</span><span class=\"s2\"> cannot \"</span>\n                                <span class=\"s2\">\"follow default field(s) </span><span class=\"si\">{default_names}</span><span class=\"s2\">\"</span>\n                                <span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">field_name</span><span class=\"o\">=</span><span class=\"n\">field_name</span><span class=\"p\">,</span>\n                                        <span class=\"n\">default_names</span><span class=\"o\">=</span><span class=\"s1\">', '</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">defaults_dict</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())))</span>\n        <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"o\">.</span><span class=\"vm\">__annotations__</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">types</span><span class=\"p\">)</span>\n        <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"o\">.</span><span class=\"vm\">__defaults__</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">defaults</span><span class=\"p\">)</span>\n        <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"n\">_field_defaults</span> <span class=\"o\">=</span> <span class=\"n\">defaults_dict</span>\n        <span class=\"c1\"># update from user namespace without overriding special namedtuple attributes</span>\n        <span class=\"k\">for</span> <span class=\"n\">key</span> <span class=\"ow\">in</span> <span class=\"n\">ns</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">key</span> <span class=\"ow\">in</span> <span class=\"n\">_prohibited</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">AttributeError</span><span class=\"p\">(</span><span class=\"s2\">\"Cannot overwrite NamedTuple attribute \"</span> <span class=\"o\">+</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n            <span class=\"k\">elif</span> <span class=\"n\">key</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">_special</span> <span class=\"ow\">and</span> <span class=\"n\">key</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">nm_tpl</span><span class=\"o\">.</span><span class=\"n\">_fields</span><span class=\"p\">:</span>\n                <span class=\"nb\">setattr</span><span class=\"p\">(</span><span class=\"n\">nm_tpl</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">ns</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span> <span class=\"n\">nm_tpl</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">NamedTuple</span><span class=\"p\">(</span><span class=\"n\">metaclass</span><span class=\"o\">=</span><span class=\"n\">NamedTupleMeta</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Typed version of namedtuple.</span>\n\n<span class=\"sd\">    Usage in Python versions &gt;= 3.6::</span>\n\n<span class=\"sd\">        class Employee(NamedTuple):</span>\n<span class=\"sd\">            name: str</span>\n<span class=\"sd\">            id: int</span>\n\n<span class=\"sd\">    This is equivalent to::</span>\n\n<span class=\"sd\">        Employee = collections.namedtuple('Employee', ['name', 'id'])</span>\n\n<span class=\"sd\">    The resulting class has an extra __annotations__ attribute, giving a</span>\n<span class=\"sd\">    dict that maps field names to types.  (The field names are also in</span>\n<span class=\"sd\">    the _fields attribute, which is part of the namedtuple API.)</span>\n<span class=\"sd\">    Alternative equivalent keyword syntax is also accepted::</span>\n\n<span class=\"sd\">        Employee = NamedTuple('Employee', name=str, id=int)</span>\n\n<span class=\"sd\">    In Python versions &lt;= 3.5 use::</span>\n\n<span class=\"sd\">        Employee = NamedTuple('Employee', [('name', str), ('id', int)])</span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"n\">_root</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">args</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">'NamedTuple.__new__(): not enough arguments'</span><span class=\"p\">)</span>\n        <span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"n\">args</span>  <span class=\"c1\"># allow the \"cls\" keyword be passed</span>\n        <span class=\"k\">if</span> <span class=\"n\">args</span><span class=\"p\">:</span>\n            <span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"n\">args</span> <span class=\"c1\"># allow the \"typename\" keyword be passed</span>\n        <span class=\"k\">elif</span> <span class=\"s1\">'typename'</span> <span class=\"ow\">in</span> <span class=\"n\">kwargs</span><span class=\"p\">:</span>\n            <span class=\"n\">typename</span> <span class=\"o\">=</span> <span class=\"n\">kwargs</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"s1\">'typename'</span><span class=\"p\">)</span>\n            <span class=\"kn\">import</span> <span class=\"nn\">warnings</span>\n            <span class=\"n\">warnings</span><span class=\"o\">.</span><span class=\"n\">warn</span><span class=\"p\">(</span><span class=\"s2\">\"Passing 'typename' as keyword argument is deprecated\"</span><span class=\"p\">,</span>\n                          <span class=\"ne\">DeprecationWarning</span><span class=\"p\">,</span> <span class=\"n\">stacklevel</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"NamedTuple.__new__() missing 1 required positional \"</span>\n                            <span class=\"s2\">\"argument: 'typename'\"</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">args</span><span class=\"p\">:</span>\n            <span class=\"k\">try</span><span class=\"p\">:</span>\n                <span class=\"n\">fields</span><span class=\"p\">,</span> <span class=\"o\">=</span> <span class=\"n\">args</span> <span class=\"c1\"># allow the \"fields\" keyword be passed</span>\n            <span class=\"k\">except</span> <span class=\"ne\">ValueError</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'NamedTuple.__new__() takes from 2 to 3 '</span>\n                                <span class=\"sa\">f</span><span class=\"s1\">'positional arguments but </span><span class=\"si\">{</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"si\">}</span><span class=\"s1\"> '</span>\n                                <span class=\"sa\">f</span><span class=\"s1\">'were given'</span><span class=\"p\">)</span> <span class=\"kn\">from</span> <span class=\"bp\">None</span>\n        <span class=\"k\">elif</span> <span class=\"s1\">'fields'</span> <span class=\"ow\">in</span> <span class=\"n\">kwargs</span> <span class=\"ow\">and</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">kwargs</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"n\">kwargs</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"s1\">'fields'</span><span class=\"p\">)</span>\n            <span class=\"kn\">import</span> <span class=\"nn\">warnings</span>\n            <span class=\"n\">warnings</span><span class=\"o\">.</span><span class=\"n\">warn</span><span class=\"p\">(</span><span class=\"s2\">\"Passing 'fields' as keyword argument is deprecated\"</span><span class=\"p\">,</span>\n                          <span class=\"ne\">DeprecationWarning</span><span class=\"p\">,</span> <span class=\"n\">stacklevel</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n\n        <span class=\"k\">if</span> <span class=\"n\">fields</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"n\">kwargs</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()</span>\n        <span class=\"k\">elif</span> <span class=\"n\">kwargs</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"Either list of fields or keywords\"</span>\n                            <span class=\"s2\">\" can be provided to NamedTuple, not both\"</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">_make_nmtuple</span><span class=\"p\">(</span><span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span>\n    <span class=\"fm\">__new__</span><span class=\"o\">.</span><span class=\"n\">__text_signature__</span> <span class=\"o\">=</span> <span class=\"s1\">'($cls, typename, fields=None, /, **kwargs)'</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_dict_new</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_typeddict_new</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">total</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">fields</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"n\">kwargs</span>\n    <span class=\"k\">elif</span> <span class=\"n\">kwargs</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s2\">\"TypedDict takes either a dict or keyword arguments,\"</span>\n                        <span class=\"s2\">\" but not both\"</span><span class=\"p\">)</span>\n\n    <span class=\"n\">ns</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'__annotations__'</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">fields</span><span class=\"p\">),</span> <span class=\"s1\">'__total__'</span><span class=\"p\">:</span> <span class=\"n\">total</span><span class=\"p\">}</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Setting correct module is necessary to make typed dict classes pickleable.</span>\n        <span class=\"n\">ns</span><span class=\"p\">[</span><span class=\"s1\">'__module__'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">_getframe</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">f_globals</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'__name__'</span><span class=\"p\">,</span> <span class=\"s1\">'__main__'</span><span class=\"p\">)</span>\n    <span class=\"k\">except</span> <span class=\"p\">(</span><span class=\"ne\">AttributeError</span><span class=\"p\">,</span> <span class=\"ne\">ValueError</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">_TypedDictMeta</span><span class=\"p\">(</span><span class=\"n\">typename</span><span class=\"p\">,</span> <span class=\"p\">(),</span> <span class=\"n\">ns</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">_check_fails</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">other</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Typed dicts are only for static structural subtyping.</span>\n    <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">'TypedDict does not support instance and class checks'</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">_TypedDictMeta</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">bases</span><span class=\"p\">,</span> <span class=\"n\">ns</span><span class=\"p\">,</span> <span class=\"n\">total</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Create new typed dict class object.</span>\n\n<span class=\"sd\">        This method is called directly when TypedDict is subclassed,</span>\n<span class=\"sd\">        or via _typeddict_new when TypedDict is instantiated. This way</span>\n<span class=\"sd\">        TypedDict supports all three syntax forms described in its docstring.</span>\n<span class=\"sd\">        Subclasses and instances of TypedDict return actual dictionaries</span>\n<span class=\"sd\">        via _dict_new.</span>\n<span class=\"sd\">        \"\"\"</span>\n        <span class=\"n\">ns</span><span class=\"p\">[</span><span class=\"s1\">'__new__'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">_typeddict_new</span> <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s1\">'TypedDict'</span> <span class=\"k\">else</span> <span class=\"n\">_dict_new</span>\n        <span class=\"n\">tp_dict</span> <span class=\"o\">=</span> <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">_TypedDictMeta</span><span class=\"p\">,</span> <span class=\"bp\">cls</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"fm\">__new__</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">,),</span> <span class=\"n\">ns</span><span class=\"p\">)</span>\n\n        <span class=\"n\">anns</span> <span class=\"o\">=</span> <span class=\"n\">ns</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'__annotations__'</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n        <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"s2\">\"TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type\"</span>\n        <span class=\"n\">anns</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"n\">_type_check</span><span class=\"p\">(</span><span class=\"n\">tp</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">tp</span> <span class=\"ow\">in</span> <span class=\"n\">anns</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()}</span>\n        <span class=\"k\">for</span> <span class=\"n\">base</span> <span class=\"ow\">in</span> <span class=\"n\">bases</span><span class=\"p\">:</span>\n            <span class=\"n\">anns</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"vm\">__dict__</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'__annotations__'</span><span class=\"p\">,</span> <span class=\"p\">{}))</span>\n        <span class=\"n\">tp_dict</span><span class=\"o\">.</span><span class=\"vm\">__annotations__</span> <span class=\"o\">=</span> <span class=\"n\">anns</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">tp_dict</span><span class=\"p\">,</span> <span class=\"s1\">'__total__'</span><span class=\"p\">):</span>\n            <span class=\"n\">tp_dict</span><span class=\"o\">.</span><span class=\"n\">__total__</span> <span class=\"o\">=</span> <span class=\"n\">total</span>\n        <span class=\"k\">return</span> <span class=\"n\">tp_dict</span>\n\n    <span class=\"fm\">__instancecheck__</span> <span class=\"o\">=</span> <span class=\"fm\">__subclasscheck__</span> <span class=\"o\">=</span> <span class=\"n\">_check_fails</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">TypedDict</span><span class=\"p\">(</span><span class=\"nb\">dict</span><span class=\"p\">,</span> <span class=\"n\">metaclass</span><span class=\"o\">=</span><span class=\"n\">_TypedDictMeta</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"A simple typed namespace. At runtime it is equivalent to a plain dict.</span>\n\n<span class=\"sd\">    TypedDict creates a dictionary type that expects all of its</span>\n<span class=\"sd\">    instances to have a certain set of keys, where each key is</span>\n<span class=\"sd\">    associated with a value of a consistent type. This expectation</span>\n<span class=\"sd\">    is not checked at runtime but is only enforced by type checkers.</span>\n<span class=\"sd\">    Usage::</span>\n\n<span class=\"sd\">        class Point2D(TypedDict):</span>\n<span class=\"sd\">            x: int</span>\n<span class=\"sd\">            y: int</span>\n<span class=\"sd\">            label: str</span>\n\n<span class=\"sd\">        a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK</span>\n<span class=\"sd\">        b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check</span>\n\n<span class=\"sd\">        assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')</span>\n\n<span class=\"sd\">    The type info can be accessed via Point2D.__annotations__. TypedDict</span>\n<span class=\"sd\">    supports two additional equivalent forms::</span>\n\n<span class=\"sd\">        Point2D = TypedDict('Point2D', x=int, y=int, label=str)</span>\n<span class=\"sd\">        Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})</span>\n\n<span class=\"sd\">    By default, all keys must be present in a TypedDict. It is possible</span>\n<span class=\"sd\">    to override this by specifying totality.</span>\n<span class=\"sd\">    Usage::</span>\n\n<span class=\"sd\">        class point2D(TypedDict, total=False):</span>\n<span class=\"sd\">            x: int</span>\n<span class=\"sd\">            y: int</span>\n\n<span class=\"sd\">    This means that a point2D TypedDict can have any of the keys omitted.A type</span>\n<span class=\"sd\">    checker is only expected to support a literal False or True as the value of</span>\n<span class=\"sd\">    the total argument. True is the default, and makes all items defined in the</span>\n<span class=\"sd\">    class body be required.</span>\n\n<span class=\"sd\">    The class syntax is only supported in Python 3.6+, while two other</span>\n<span class=\"sd\">    syntax forms work for Python 2.7 and 3.2+</span>\n<span class=\"sd\">    \"\"\"</span>\n\n\n<div class=\"viewcode-block\" id=\"NewType\"><a class=\"viewcode-back\" href=\"../api/stable/napari.types.html#napari.types.NewType\">[docs]</a><span class=\"k\">def</span> <span class=\"nf\">NewType</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">tp</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"NewType creates simple unique types with almost zero</span>\n<span class=\"sd\">    runtime overhead. NewType(name, tp) is considered a subtype of tp</span>\n<span class=\"sd\">    by static type checkers. At runtime, NewType(name, tp) returns</span>\n<span class=\"sd\">    a dummy function that simply returns its argument. Usage::</span>\n\n<span class=\"sd\">        UserId = NewType('UserId', int)</span>\n\n<span class=\"sd\">        def name_by_id(user_id: UserId) -&gt; str:</span>\n<span class=\"sd\">            ...</span>\n\n<span class=\"sd\">        UserId('user')          # Fails type check</span>\n\n<span class=\"sd\">        name_by_id(42)          # Fails type check</span>\n<span class=\"sd\">        name_by_id(UserId(42))  # OK</span>\n\n<span class=\"sd\">        num = UserId(5) + 1     # type: int</span>\n<span class=\"sd\">    \"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">new_type</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">x</span>\n\n    <span class=\"n\">new_type</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">=</span> <span class=\"n\">name</span>\n    <span class=\"n\">new_type</span><span class=\"o\">.</span><span class=\"n\">__supertype__</span> <span class=\"o\">=</span> <span class=\"n\">tp</span>\n    <span class=\"k\">return</span> <span class=\"n\">new_type</span></div>\n\n\n<span class=\"c1\"># Python-version-specific alias (Python 2: unicode; Python 3: str)</span>\n<span class=\"n\">Text</span> <span class=\"o\">=</span> <span class=\"nb\">str</span>\n\n\n<span class=\"c1\"># Constant that's True when type checking, but False here.</span>\n<span class=\"n\">TYPE_CHECKING</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">IO</span><span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">[</span><span class=\"n\">AnyStr</span><span class=\"p\">]):</span>\n    <span class=\"sd\">\"\"\"Generic base class for TextIO and BinaryIO.</span>\n\n<span class=\"sd\">    This is an abstract, generic version of the return of open().</span>\n\n<span class=\"sd\">    NOTE: This does not distinguish between the different possible</span>\n<span class=\"sd\">    classes (text vs. binary, read vs. write vs. read/write,</span>\n<span class=\"sd\">    append-only, unbuffered).  The TextIO and BinaryIO subclasses</span>\n<span class=\"sd\">    below capture the distinctions between text vs. binary, which is</span>\n<span class=\"sd\">    pervasive in the interface; however we currently do not offer a</span>\n<span class=\"sd\">    way to track the other distinctions in the type system.</span>\n<span class=\"sd\">    \"\"\"</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">mode</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">str</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">name</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">str</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">close</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">closed</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">fileno</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">flush</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isatty</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">read</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">AnyStr</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">readable</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">readline</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">limit</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">AnyStr</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">readlines</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">hint</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">AnyStr</span><span class=\"p\">]:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">seek</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">whence</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">seekable</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">tell</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">truncate</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">writable</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">AnyStr</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">writelines</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lines</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">AnyStr</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__enter__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">'IO[AnyStr]'</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__exit__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">traceback</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">BinaryIO</span><span class=\"p\">(</span><span class=\"n\">IO</span><span class=\"p\">[</span><span class=\"nb\">bytes</span><span class=\"p\">]):</span>\n    <span class=\"sd\">\"\"\"Typed version of the return of open() in binary mode.\"\"\"</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"nb\">bytearray</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__enter__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">'BinaryIO'</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">TextIO</span><span class=\"p\">(</span><span class=\"n\">IO</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]):</span>\n    <span class=\"sd\">\"\"\"Typed version of the return of open() in text mode.\"\"\"</span>\n\n    <span class=\"vm\">__slots__</span> <span class=\"o\">=</span> <span class=\"p\">()</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">buffer</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">BinaryIO</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">encoding</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">str</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">errors</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">line_buffering</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">newlines</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Any</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"nd\">@abstractmethod</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__enter__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">'TextIO'</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">io</span><span class=\"p\">:</span>\n    <span class=\"sd\">\"\"\"Wrapper namespace for IO generic classes.\"\"\"</span>\n\n    <span class=\"n\">__all__</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'IO'</span><span class=\"p\">,</span> <span class=\"s1\">'TextIO'</span><span class=\"p\">,</span> <span class=\"s1\">'BinaryIO'</span><span class=\"p\">]</span>\n    <span class=\"n\">IO</span> <span class=\"o\">=</span> <span class=\"n\">IO</span>\n    <span class=\"n\">TextIO</span> <span class=\"o\">=</span> <span class=\"n\">TextIO</span>\n    <span class=\"n\">BinaryIO</span> <span class=\"o\">=</span> <span class=\"n\">BinaryIO</span>\n\n\n<span class=\"n\">io</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">=</span> <span class=\"vm\">__name__</span> <span class=\"o\">+</span> <span class=\"s1\">'.io'</span>\n<span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"p\">[</span><span class=\"n\">io</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">io</span>\n\n<span class=\"n\">Pattern</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">stdlib_re</span><span class=\"o\">.</span><span class=\"n\">Pattern</span><span class=\"p\">,</span> <span class=\"n\">AnyStr</span><span class=\"p\">)</span>\n<span class=\"n\">Match</span> <span class=\"o\">=</span> <span class=\"n\">_alias</span><span class=\"p\">(</span><span class=\"n\">stdlib_re</span><span class=\"o\">.</span><span class=\"n\">Match</span><span class=\"p\">,</span> <span class=\"n\">AnyStr</span><span class=\"p\">)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">re</span><span class=\"p\">:</span>\n    <span class=\"sd\">\"\"\"Wrapper namespace for re type aliases.\"\"\"</span>\n\n    <span class=\"n\">__all__</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'Pattern'</span><span class=\"p\">,</span> <span class=\"s1\">'Match'</span><span class=\"p\">]</span>\n    <span class=\"n\">Pattern</span> <span class=\"o\">=</span> <span class=\"n\">Pattern</span>\n    <span class=\"n\">Match</span> <span class=\"o\">=</span> <span class=\"n\">Match</span>\n\n\n<span class=\"n\">re</span><span class=\"o\">.</span><span class=\"vm\">__name__</span> <span class=\"o\">=</span> <span class=\"vm\">__name__</span> <span class=\"o\">+</span> <span class=\"s1\">'.re'</span>\n<span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"p\">[</span><span class=\"n\">re</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">re</span>\n</pre></div>\n      ","pageHeaders":[],"ipynbSource":"","mdSource":""}},"__N_SSG":true}