/**
 * Script for pre-rendering the napari.org React application. Pre-rendering is a
 * form of Static Site Generation, a technique for rendering HTML given some
 * data and an HTML template.
 *
 * Pre-rendering is important so that website content is available on initial
 * load for non-JavaScript users and search engine bots. It also improves first
 * load performance because React can reuse the existing nodes so that it
 * doesn't have to render the entire application from scratch.
 */

import cheerio, { Cheerio, Element } from 'cheerio';
import { promises } from 'fs';
import { resolve } from 'path';
import yaml from 'yaml';

import { TOCHeader } from '@/context/jupyterBook';

import {
  getGlobalHeaders,
  mediaStyles,
  renderAppToString,
} from './renderAppToString';

const fs = promises;

interface JupyterBookFileData {
  file: string;
}

interface JupyterBookSection extends JupyterBookFileData {
  sections: JupyterBookSection[];
}

interface JupyterBookChapter {
  chapters: JupyterBookSection[];
}

type JupyterBookTOCItem =
  | JupyterBookChapter
  | JupyterBookSection
  | JupyterBookFileData;

type JupyterBookTOC = JupyterBookTOCItem[];

function isJupyterBookChapter(
  item: JupyterBookTOCItem,
): item is JupyterBookChapter {
  return !!(item as JupyterBookChapter).chapters;
}

function isJupyterBookSection(
  item: JupyterBookTOCItem,
): item is JupyterBookSection {
  return !!(item as JupyterBookSection).sections;
}

/**
 * @param file The file to check
 * @returns True if it exists, false otherwise.
 */
async function fileExists(file: string) {
  try {
    await fs.access(file);
    return true;
  } catch (_) {
    return false;
  }
}

/**
 * Parses the Jupyter book `_toc.yml` file using Depth First Search to get a
 * list of HTML files generated by Jupyter Book.
 *
 * @returns The list of HTML files.
 */
async function getHTMLFiles() {
  const tocString = await fs.readFile('_toc.yml', 'utf-8');
  const tocData = yaml.parse(tocString) as JupyterBookTOC;

  const htmlFiles: string[] = [];
  const stack = tocData.slice().reverse();

  while (stack.length > 0) {
    const item = stack.pop();
    if (!item) break;

    if (isJupyterBookChapter(item)) {
      const { chapters } = item;

      for (const chapter of chapters) {
        if (chapter.file) {
          htmlFiles.push(`${chapter.file}.html`);

          if (chapter.sections) {
            stack.push(...chapter.sections);
          }
        }
      }
    } else if (item.file) {
      htmlFiles.push(`${item.file}.html`);

      if (isJupyterBookSection(item) && item.sections) {
        stack.push(...item.sections);
      }
    }
  }

  // Get the full paths of each HTML file and filter out any files that don't
  // exist for some reason.
  const filteredHtmlFiles: string[] = [];
  await Promise.all(
    htmlFiles.map(async (file) => {
      const fullPath = resolve(__dirname, '../_build/html', file);
      if (await fileExists(fullPath)) {
        filteredHtmlFiles.push(fullPath);
      }
    }),
  );

  return filteredHtmlFiles;
}

function getPageHeaders(contentToc: Cheerio<Element>) {
  return contentToc
    .find('#page-toc > ul > li > ul > li > a')
    .toArray()
    .map<TOCHeader>((element) => {
      const link = cheerio(element);
      const href = link.attr('href') ?? '';

      return {
        // Remove the starting hash on the link if it exists.
        id: href.replace(/^#/, ''),
        text: link.text(),
      };
    });
}

function getTocSelector(level = 1) {
  return `.toctree-l${level}`;
}

function getGlobalTocHeaders(globalToc: Cheerio<Element>) {
  return getGlobalHeaders<Element>({
    getRootNodes: () => globalToc.find(getTocSelector()).toArray(),
    getLinkData: (node) => {
      const link = cheerio(node).find('a').first();

      return {
        href: link.attr('href') ?? '',
        text: link.text(),
      };
    },
    getNextNodes: (node, level) =>
      cheerio(node).find(getTocSelector(level)).toArray(),
  });
}

/**
 * Pre-renders the React application component into an HTML file.
 *
 * @param file The HTML file to pre-render.
 */
async function preRenderFile(file: string) {
  const rawHtml = await fs.readFile(file, 'utf-8');
  const $ = cheerio.load(rawHtml);

  const pageBody = $('#page-body');
  const pageHeader = pageBody.find('h1').first();
  const pageToc = $('#page-toc');
  const globalToc = $('#global-toc');

  // Remove header link automatically added by Jupyter Book.
  pageBody.find('.headerlink').remove();

  // Remove any development specific HTML tags.
  $('[data-dev]').remove();

  // Add SSR styles to fresnel style element.
  $('#fresnel').text(mediaStyles);

  // Get page title from header text content.
  const pageTitle = pageHeader.text();

  // Extract h1 from HTML and render application with the header removed, but
  // use a copy so that we don't remove it from the HTML file. The client will
  // need the h1 still in the HTML file to hydrate the UI.
  const pageBodyClone = pageBody.clone();
  pageBodyClone.find('h1').remove();
  const pageBodyHtml = pageBodyClone.html() ?? '';

  // Render application HTML using parsed page data.
  const appHtml = renderAppToString({
    ...getGlobalTocHeaders(globalToc),
    pageBodyHtml,
    pageTitle,
    pageHeaders: getPageHeaders(pageToc),
  });

  // Write application HTML to #app node.
  $('#app').html(appHtml);

  // Overwrite existing HTML file with new HTML.
  await fs.writeFile(file, $.html());
}

async function preRender() {
  const files = await getHTMLFiles();
  await Promise.all(files.map(preRenderFile));
  console.log(`Pre-rendered ${files.length} files!`);
}

preRender().catch((error) => console.error('Pre-rendering failed!', error));
