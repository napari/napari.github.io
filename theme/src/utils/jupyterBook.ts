/*
  eslint-disable
    no-await-in-loop,
    import/no-extraneous-dependencies
  */

import fs from 'fs-extra';
import { resolve } from 'path';
import yaml from 'yaml';

interface JupyterBookFileData {
  file: string;
}

interface JupyterBookSection extends JupyterBookFileData {
  sections: JupyterBookSection[];
}

interface JupyterBookChapter {
  chapters: JupyterBookSection[];
}

type JupyterBookTOCItem =
  | JupyterBookChapter
  | JupyterBookSection
  | JupyterBookFileData;

type JupyterBookTOC = JupyterBookTOCItem[];

function isJupyterBookChapter(
  item: JupyterBookTOCItem,
): item is JupyterBookChapter {
  return !!(item as JupyterBookChapter).chapters;
}

function isJupyterBookSection(
  item: JupyterBookTOCItem,
): item is JupyterBookSection {
  return !!(item as JupyterBookSection).sections;
}

/**
 * Parses the Jupyter book `_toc.yml` file to get a list of files generated by
 * Jupyter Book.
 *
 * @returns The list of files.
 */
export async function getTOCFiles(): Promise<string[]> {
  const tocString = await fs.readFile('_toc.yml', 'utf-8');
  const tocData = yaml.parse(tocString) as JupyterBookTOC;

  const files: string[] = [];
  const stack = tocData.slice().reverse();

  // Use DFS to traverse YAML data structure.
  while (stack.length > 0) {
    const item = stack.pop();
    if (!item) break;

    if (isJupyterBookChapter(item)) {
      const { chapters } = item;

      for (const chapter of chapters) {
        if (chapter.file) {
          files.push(chapter.file);

          if (chapter.sections) {
            stack.push(...chapter.sections);
          }
        }
      }
    } else if (item.file) {
      files.push(item.file);

      if (isJupyterBookSection(item) && item.sections) {
        stack.push(...item.sections);
      }
    }
  }

  return files;
}

/**
 * Directories that should be ignored when looking for HTML files.
 */
const IGNORED_DIRS = [
  // Static files
  '_images',
  '_static',
  '_panels_static',

  // Documentation source code. Instead of copying this over, we can link the
  // user to the source code in GitHub instead so that we can reduce the
  // deployment size.
  '_sources',
];

/**
 * Files that should be ignored when an HTML file is found.
 */
const IGNORED_FILES = ['genindex.html', 'py-modindex.html'];

/**
 * Returns a list of HTML files that are created in _build/html.
 *
 * @returns The list of HTML files.
 */
export async function getHTMLFiles(): Promise<string[]> {
  const buildDir = resolve(__dirname, '../../../_build/html');
  const files = [buildDir];
  const result = new Set<string>();

  // Use DFS to find all deeply nested HTML files.
  while (files.length > 0) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const file = files.pop()!;
    const stats = await fs.stat(file);

    if (
      // Is directory.
      stats.isDirectory() &&
      // Is not an ignored directory.
      !IGNORED_DIRS.some((ignoredDir) => file.includes(ignoredDir))
    ) {
      // Add directory files to the stack.
      const nextFiles = await fs.readdir(file);
      for (const nextFile of nextFiles) {
        files.push(resolve(file, nextFile));
      }
    } else if (
      // Is file.
      stats.isFile() &&
      // Is HTML file.
      file.endsWith('.html') &&
      // Is not an ignored file.
      !IGNORED_FILES.some((ignoredFile) => file.includes(ignoredFile))
    ) {
      result.add(file);
    }
  }

  return Array.from(result);
}
