{"pageProps":{"state":{"globalHeaders":{"https://napari-hub.org":{"level":1,"children":[],"href":"https://napari-hub.org","text":"napari hub"},"https://github.com/napari/napari":{"level":1,"children":[],"href":"https://github.com/napari/napari","text":"napari source code"},"/roadmaps/index.html":{"level":1,"children":["/roadmaps/0_4.html","/roadmaps/0_3_retrospective.html","/roadmaps/0_3.html"],"href":"/roadmaps/index.html","text":"Roadmaps"},"/roadmaps/0_3.html":{"level":2,"children":[],"href":"/roadmaps/0_3.html","text":"Roadmap 0.3"},"/roadmaps/0_3_retrospective.html":{"level":2,"children":[],"href":"/roadmaps/0_3_retrospective.html","text":"Roadmap 0.3 Retrospective"},"/roadmaps/0_4.html":{"level":2,"children":[],"href":"/roadmaps/0_4.html","text":"Roadmap 0.4"},"/release/index.html":{"level":1,"children":["/release/release_0_4_12.html","/release/release_0_4_11.html","/release/release_0_4_10.html","/release/release_0_4_9.html","/release/release_0_4_8.html","/release/release_0_4_7.html","/release/release_0_4_6.html","/release/release_0_4_5.html","/release/release_0_4_4.html","/release/release_0_4_3.html","/release/release_0_4_2.html","/release/release_0_4_1.html","/release/release_0_4_0.html","/release/release_0_3_8.html","/release/release_0_3_7.html","/release/release_0_3_6.html","/release/release_0_3_5.html","/release/release_0_3_4.html","/release/release_0_3_3.html","/release/release_0_3_2.html","/release/release_0_3_1.html","/release/release_0_3_0.html","/release/release_0_2_12.html","/release/release_0_2_11.html","/release/release_0_2_10.html","/release/release_0_2_9.html","/release/release_0_2_8.html","/release/release_0_2_7.html","/release/release_0_2_6.html","/release/release_0_2_5.html","/release/release_0_2_4.html","/release/release_0_2_3.html","/release/release_0_2_1.html","/release/release_0_2_0.html","/release/release_0_1_5.html","/release/release_0_1_3.html","/release/release_0_1_0.html"],"href":"/release/index.html","text":"Release notes"},"/release/release_0_1_0.html":{"level":2,"children":[],"href":"/release/release_0_1_0.html","text":"napari 0.1.0"},"/release/release_0_1_3.html":{"level":2,"children":[],"href":"/release/release_0_1_3.html","text":"napari 0.1.3"},"/release/release_0_1_5.html":{"level":2,"children":[],"href":"/release/release_0_1_5.html","text":"napari 0.1.5"},"/release/release_0_2_0.html":{"level":2,"children":[],"href":"/release/release_0_2_0.html","text":"napari 0.2.0"},"/release/release_0_2_1.html":{"level":2,"children":[],"href":"/release/release_0_2_1.html","text":"napari 0.2.1"},"/release/release_0_2_3.html":{"level":2,"children":[],"href":"/release/release_0_2_3.html","text":"napari 0.2.3"},"/release/release_0_2_4.html":{"level":2,"children":[],"href":"/release/release_0_2_4.html","text":"napari 0.2.4"},"/release/release_0_2_5.html":{"level":2,"children":[],"href":"/release/release_0_2_5.html","text":"napari 0.2.5"},"/release/release_0_2_6.html":{"level":2,"children":[],"href":"/release/release_0_2_6.html","text":"napari 0.2.6"},"/release/release_0_2_7.html":{"level":2,"children":[],"href":"/release/release_0_2_7.html","text":"napari 0.2.7"},"/release/release_0_2_8.html":{"level":2,"children":[],"href":"/release/release_0_2_8.html","text":"napari 0.2.8"},"/release/release_0_2_9.html":{"level":2,"children":[],"href":"/release/release_0_2_9.html","text":"napari 0.2.9"},"/release/release_0_2_10.html":{"level":2,"children":[],"href":"/release/release_0_2_10.html","text":"napari 0.2.10"},"/release/release_0_2_11.html":{"level":2,"children":[],"href":"/release/release_0_2_11.html","text":"napari 0.2.11"},"/release/release_0_2_12.html":{"level":2,"children":[],"href":"/release/release_0_2_12.html","text":"napari 0.2.12"},"/release/release_0_3_0.html":{"level":2,"children":[],"href":"/release/release_0_3_0.html","text":"napari 0.3.0"},"/release/release_0_3_1.html":{"level":2,"children":[],"href":"/release/release_0_3_1.html","text":"napari 0.3.1"},"/release/release_0_3_2.html":{"level":2,"children":[],"href":"/release/release_0_3_2.html","text":"napari 0.3.2"},"/release/release_0_3_3.html":{"level":2,"children":[],"href":"/release/release_0_3_3.html","text":"napari 0.3.3"},"/release/release_0_3_4.html":{"level":2,"children":[],"href":"/release/release_0_3_4.html","text":"napari 0.3.4"},"/release/release_0_3_5.html":{"level":2,"children":[],"href":"/release/release_0_3_5.html","text":"napari 0.3.5"},"/release/release_0_3_6.html":{"level":2,"children":[],"href":"/release/release_0_3_6.html","text":"napari 0.3.6"},"/release/release_0_3_7.html":{"level":2,"children":[],"href":"/release/release_0_3_7.html","text":"napari 0.3.7"},"/release/release_0_3_8.html":{"level":2,"children":[],"href":"/release/release_0_3_8.html","text":"napari 0.3.8"},"/release/release_0_4_0.html":{"level":2,"children":[],"href":"/release/release_0_4_0.html","text":"napari 0.4.0"},"/release/release_0_4_1.html":{"level":2,"children":[],"href":"/release/release_0_4_1.html","text":"napari 0.4.1"},"/release/release_0_4_2.html":{"level":2,"children":[],"href":"/release/release_0_4_2.html","text":"napari 0.4.2"},"/release/release_0_4_3.html":{"level":2,"children":[],"href":"/release/release_0_4_3.html","text":"napari 0.4.3"},"/release/release_0_4_4.html":{"level":2,"children":[],"href":"/release/release_0_4_4.html","text":"napari 0.4.4"},"/release/release_0_4_5.html":{"level":2,"children":[],"href":"/release/release_0_4_5.html","text":"napari 0.4.5"},"/release/release_0_4_6.html":{"level":2,"children":[],"href":"/release/release_0_4_6.html","text":"napari 0.4.6"},"/release/release_0_4_7.html":{"level":2,"children":[],"href":"/release/release_0_4_7.html","text":"napari 0.4.7"},"/release/release_0_4_8.html":{"level":2,"children":[],"href":"/release/release_0_4_8.html","text":"napari 0.4.8"},"/release/release_0_4_9.html":{"level":2,"children":[],"href":"/release/release_0_4_9.html","text":"napari 0.4.9"},"/release/release_0_4_10.html":{"level":2,"children":[],"href":"/release/release_0_4_10.html","text":"napari 0.4.10"},"/release/release_0_4_11.html":{"level":2,"children":[],"href":"/release/release_0_4_11.html","text":"napari 0.4.11"},"/release/release_0_4_12.html":{"level":2,"children":[],"href":"/release/release_0_4_12.html","text":"napari 0.4.12"},"/glossary.html":{"level":1,"children":[],"href":"/glossary.html","text":"Glossary"},"/developers/index.html":{"level":1,"children":["/developers/benchmarks.html","/developers/contributing.html","/developers/core_dev_guide.html","/developers/profiling.html","/developers/release.html","/developers/testing.html","/developers/docs.html","/developers/translations.html"],"href":"/developers/index.html","text":"Developer resources"},"/developers/translations.html":{"level":2,"children":[],"href":"/developers/translations.html","text":"Translations"},"/developers/docs.html":{"level":2,"children":[],"href":"/developers/docs.html","text":"Organization of Documentation for napari"},"/developers/testing.html":{"level":2,"children":[],"href":"/developers/testing.html","text":"Testing"},"/developers/release.html":{"level":2,"children":[],"href":"/developers/release.html","text":"Release guide"},"/developers/profiling.html":{"level":2,"children":[],"href":"/developers/profiling.html","text":"Profiling"},"/developers/core_dev_guide.html":{"level":2,"children":[],"href":"/developers/core_dev_guide.html","text":"Core Developer guide"},"/developers/contributing.html":{"level":2,"children":[],"href":"/developers/contributing.html","text":"Contributing guide"},"/developers/benchmarks.html":{"level":2,"children":[],"href":"/developers/benchmarks.html","text":"Benchmarks"},"/api/stable/index.html":{"level":1,"children":["/api/stable/napari.layers.html","/api/stable/napari.view_layers.html","/api/stable/napari.types.html","/api/stable/napari.utils.html","/api/stable/napari.plugins.html","/api/stable/napari.components.html","/api/stable/napari.qt.threading.html","/api/stable/napari.utils.perf.html","/api/stable/napari.html","/api/stable/napari.html"],"href":"/api/stable/index.html","text":"API reference"},"/api/stable/napari.html":{"level":2,"children":["/api/stable/napari.Viewer.html"],"href":"/api/stable/napari.html","text":"napari"},"/api/stable/napari.Viewer.html":{"level":3,"children":[],"href":"/api/stable/napari.Viewer.html","text":"napari.Viewer"},"/api/stable/napari.utils.perf.html":{"level":2,"children":["/api/stable/napari.utils.perf.PerfEvent.html"],"href":"/api/stable/napari.utils.perf.html","text":"napari.utils.perf"},"/api/stable/napari.utils.perf.PerfEvent.html":{"level":3,"children":[],"href":"/api/stable/napari.utils.perf.PerfEvent.html","text":"napari.utils.perf.PerfEvent"},"/api/stable/napari.qt.threading.html":{"level":2,"children":["/api/stable/napari.qt.threading.FunctionWorker.html","/api/stable/napari.qt.threading.GeneratorWorker.html","/api/stable/napari.qt.threading.GeneratorWorkerSignals.html","/api/stable/napari.qt.threading.WorkerBase.html","/api/stable/napari.qt.threading.WorkerBaseSignals.html"],"href":"/api/stable/napari.qt.threading.html","text":"napari.qt.threading"},"/api/stable/napari.qt.threading.WorkerBaseSignals.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.WorkerBaseSignals.html","text":"napari.qt.threading.WorkerBaseSignals"},"/api/stable/napari.qt.threading.WorkerBase.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.WorkerBase.html","text":"napari.qt.threading.WorkerBase"},"/api/stable/napari.qt.threading.GeneratorWorkerSignals.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.GeneratorWorkerSignals.html","text":"napari.qt.threading.GeneratorWorkerSignals"},"/api/stable/napari.qt.threading.GeneratorWorker.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.GeneratorWorker.html","text":"napari.qt.threading.GeneratorWorker"},"/api/stable/napari.qt.threading.FunctionWorker.html":{"level":3,"children":[],"href":"/api/stable/napari.qt.threading.FunctionWorker.html","text":"napari.qt.threading.FunctionWorker"},"/api/stable/napari.components.html":{"level":2,"children":["/api/stable/napari.components.Camera.html","/api/stable/napari.components.Dims.html","/api/stable/napari.components.LayerList.html","/api/stable/napari.components.ViewerModel.html"],"href":"/api/stable/napari.components.html","text":"napari.components"},"/api/stable/napari.components.ViewerModel.html":{"level":3,"children":[],"href":"/api/stable/napari.components.ViewerModel.html","text":"napari.components.ViewerModel"},"/api/stable/napari.components.LayerList.html":{"level":3,"children":[],"href":"/api/stable/napari.components.LayerList.html","text":"napari.components.LayerList"},"/api/stable/napari.components.Dims.html":{"level":3,"children":[],"href":"/api/stable/napari.components.Dims.html","text":"napari.components.Dims"},"/api/stable/napari.components.Camera.html":{"level":3,"children":[],"href":"/api/stable/napari.components.Camera.html","text":"napari.components.Camera"},"/api/stable/napari.plugins.html":{"level":2,"children":["/api/stable/napari.plugins.NapariPluginManager.html"],"href":"/api/stable/napari.plugins.html","text":"napari.plugins"},"/api/stable/napari.plugins.NapariPluginManager.html":{"level":3,"children":[],"href":"/api/stable/napari.plugins.NapariPluginManager.html","text":"napari.plugins.NapariPluginManager"},"/api/stable/napari.utils.html":{"level":2,"children":["/api/stable/napari.utils.Colormap.html","/api/stable/napari.utils.nbscreenshot.html","/api/stable/napari.utils.progress.html"],"href":"/api/stable/napari.utils.html","text":"napari.utils"},"/api/stable/napari.utils.progress.html":{"level":3,"children":[],"href":"/api/stable/napari.utils.progress.html","text":"napari.utils.progress"},"/api/stable/napari.utils.nbscreenshot.html":{"level":3,"children":[],"href":"/api/stable/napari.utils.nbscreenshot.html","text":"napari.utils.nbscreenshot"},"/api/stable/napari.utils.Colormap.html":{"level":3,"children":[],"href":"/api/stable/napari.utils.Colormap.html","text":"napari.utils.Colormap"},"/api/stable/napari.types.html":{"level":2,"children":["/api/stable/napari.types.ArrayBase.html","/api/stable/napari.types.Path.html","/api/stable/napari.types.SampleDict.html","/api/stable/napari.types.TracebackType.html","/api/stable/napari.types.TypedDict.html","/api/stable/napari.types.partial.html"],"href":"/api/stable/napari.types.html","text":"napari.types"},"/api/stable/napari.types.partial.html":{"level":3,"children":[],"href":"/api/stable/napari.types.partial.html","text":"napari.types.partial"},"/api/stable/napari.types.TypedDict.html":{"level":3,"children":[],"href":"/api/stable/napari.types.TypedDict.html","text":"napari.types.TypedDict"},"/api/stable/napari.types.TracebackType.html":{"level":3,"children":[],"href":"/api/stable/napari.types.TracebackType.html","text":"napari.types.TracebackType"},"/api/stable/napari.types.SampleDict.html":{"level":3,"children":[],"href":"/api/stable/napari.types.SampleDict.html","text":"napari.types.SampleDict"},"/api/stable/napari.types.Path.html":{"level":3,"children":[],"href":"/api/stable/napari.types.Path.html","text":"napari.types.Path"},"/api/stable/napari.types.ArrayBase.html":{"level":3,"children":[],"href":"/api/stable/napari.types.ArrayBase.html","text":"napari.types.ArrayBase"},"/api/stable/napari.view_layers.html":{"level":2,"children":["/api/stable/napari.view_layers.Viewer.html"],"href":"/api/stable/napari.view_layers.html","text":"napari.view_layers"},"/api/stable/napari.view_layers.Viewer.html":{"level":3,"children":[],"href":"/api/stable/napari.view_layers.Viewer.html","text":"napari.view_layers.Viewer"},"/api/stable/napari.layers.html":{"level":2,"children":["/api/stable/napari.layers.Image.html","/api/stable/napari.layers.Labels.html","/api/stable/napari.layers.Layer.html","/api/stable/napari.layers.Points.html","/api/stable/napari.layers.Shapes.html","/api/stable/napari.layers.Surface.html","/api/stable/napari.layers.Tracks.html","/api/stable/napari.layers.Vectors.html"],"href":"/api/stable/napari.layers.html","text":"napari.layers"},"/api/stable/napari.layers.Vectors.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Vectors.html","text":"napari.layers.Vectors"},"/api/stable/napari.layers.Tracks.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Tracks.html","text":"napari.layers.Tracks"},"/api/stable/napari.layers.Surface.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Surface.html","text":"napari.layers.Surface"},"/api/stable/napari.layers.Shapes.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Shapes.html","text":"napari.layers.Shapes"},"/api/stable/napari.layers.Points.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Points.html","text":"napari.layers.Points"},"/api/stable/napari.layers.Layer.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Layer.html","text":"napari.layers.Layer"},"/api/stable/napari.layers.Labels.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Labels.html","text":"napari.layers.Labels"},"/api/stable/napari.layers.Image.html":{"level":3,"children":[],"href":"/api/stable/napari.layers.Image.html","text":"napari.layers.Image"},"/community/index.html":{"level":1,"children":["/community/mission_and_values.html","/community/team.html","/community/code_of_conduct.html","/community/code_of_conduct_reporting.html","/community/governance.html","/community/working_groups.html","/community/meeting_schedule.html"],"href":"/community/index.html","text":"Community"},"/community/meeting_schedule.html":{"level":2,"children":[],"href":"/community/meeting_schedule.html","text":"Meeting schedule"},"/community/working_groups.html":{"level":2,"children":[],"href":"/community/working_groups.html","text":"Working groups"},"/community/governance.html":{"level":2,"children":[],"href":"/community/governance.html","text":"Governance model"},"/community/code_of_conduct_reporting.html":{"level":2,"children":[],"href":"/community/code_of_conduct_reporting.html","text":"Handling Code of Conduct reports"},"/community/code_of_conduct.html":{"level":2,"children":[],"href":"/community/code_of_conduct.html","text":"Code of Conduct"},"/community/team.html":{"level":2,"children":[],"href":"/community/team.html","text":"About the project and team"},"/community/mission_and_values.html":{"level":2,"children":[],"href":"/community/mission_and_values.html","text":"Mission and Values"},"/plugins/stable/index.html":{"level":1,"children":["/plugins/stable/for_plugin_developers.html","/plugins/stable/hook_specifications.html","/plugins/stable/for_napari_developers.html","/plugins/stable/best_practices.html","/plugins/stable/npe2_migration_guide.html","/plugins/stable/npe2_getting_started.html","/plugins/stable/npe2_manifest_specification.html","/plugins/stable/find-and-install-plugin.html"],"href":"/plugins/stable/index.html","text":"Plugins"},"/plugins/stable/find-and-install-plugin.html":{"level":2,"children":[],"href":"/plugins/stable/find-and-install-plugin.html","text":"Finding and installing a napari plugin"},"/plugins/stable/npe2_manifest_specification.html":{"level":2,"children":[],"href":"/plugins/stable/npe2_manifest_specification.html","text":"npe2 manifest specification"},"/plugins/stable/npe2_getting_started.html":{"level":2,"children":[],"href":"/plugins/stable/npe2_getting_started.html","text":"npe2 getting started guide"},"/plugins/stable/npe2_migration_guide.html":{"level":2,"children":[],"href":"/plugins/stable/npe2_migration_guide.html","text":"npe2 migration guide"},"/plugins/stable/best_practices.html":{"level":2,"children":[],"href":"/plugins/stable/best_practices.html","text":"Best practices when developing napari plugins"},"/plugins/stable/for_napari_developers.html":{"level":2,"children":[],"href":"/plugins/stable/for_napari_developers.html","text":"napari plugin architecture"},"/plugins/stable/hook_specifications.html":{"level":2,"children":[],"href":"/plugins/stable/hook_specifications.html","text":"napari hook specification reference"},"/plugins/stable/for_plugin_developers.html":{"level":2,"children":[],"href":"/plugins/stable/for_plugin_developers.html","text":"Creating a napari plugin"},"/guides/stable/index.html":{"level":1,"children":["/guides/stable/magicgui.html","/guides/stable/event_loop.html","/guides/stable/threading.html","/guides/stable/rendering-explanation.html","/guides/stable/rendering.html","/guides/stable/performance.html","/guides/stable/3D_interactivity.html","/guides/stable/events_reference.html","/guides/stable/contexts_expressions.html"],"href":"/guides/stable/index.html","text":"In-depth explanations"},"/guides/stable/contexts_expressions.html":{"level":2,"children":[],"href":"/guides/stable/contexts_expressions.html","text":"Contexts and Expressions in napari"},"/guides/stable/events_reference.html":{"level":2,"children":[],"href":"/guides/stable/events_reference.html","text":"Events reference"},"/guides/stable/3D_interactivity.html":{"level":2,"children":[],"href":"/guides/stable/3D_interactivity.html","text":"3D interactivity"},"/guides/stable/performance.html":{"level":2,"children":[],"href":"/guides/stable/performance.html","text":"napari performance"},"/guides/stable/rendering.html":{"level":2,"children":[],"href":"/guides/stable/rendering.html","text":"Asynchronous rendering"},"/guides/stable/rendering-explanation.html":{"level":2,"children":[],"href":"/guides/stable/rendering-explanation.html","text":"Rendering in napari"},"/guides/stable/threading.html":{"level":2,"children":[],"href":"/guides/stable/threading.html","text":"Multithreading in napari"},"/guides/stable/event_loop.html":{"level":2,"children":[],"href":"/guides/stable/event_loop.html","text":"An introduction to the event loop in napari"},"/guides/stable/magicgui.html":{"level":2,"children":[],"href":"/guides/stable/magicgui.html","text":"Using magicgui in napari"},"/howtos/index.html":{"level":1,"children":["/howtos/connecting_events.html","/howtos/napari_imageJ.html","/howtos/docker.html","/howtos/perfmon.html"],"href":"/howtos/index.html","text":"How-to guides"},"/howtos/perfmon.html":{"level":2,"children":[],"href":"/howtos/perfmon.html","text":"Performance monitoring"},"/howtos/docker.html":{"level":2,"children":[],"href":"/howtos/docker.html","text":"Napari in Docker"},"/howtos/napari_imageJ.html":{"level":2,"children":[],"href":"/howtos/napari_imageJ.html","text":"napari + ImageJ how-to guide"},"/howtos/connecting_events.html":{"level":2,"children":[],"href":"/howtos/connecting_events.html","text":"Hooking up your own events"},"/tutorials/index.html":{"level":1,"children":["/tutorials/segmentation/index.html","/tutorials/tracking/index.html","/tutorials/applications/annotate_points.html","/tutorials/applications/dask.html","/tutorials/further-resources/napari-workshops.html","/tutorials/tracking/cell_tracking.html","/tutorials/segmentation/annotate_segmentation.html"],"href":"/tutorials/index.html","text":"Tutorials"},"/tutorials/segmentation/annotate_segmentation.html":{"level":2,"children":[],"href":"/tutorials/segmentation/annotate_segmentation.html","text":"Annotating segmentation with text and bounding boxes"},"/tutorials/tracking/cell_tracking.html":{"level":2,"children":[],"href":"/tutorials/tracking/cell_tracking.html","text":"Single cell tracking with napari"},"/tutorials/further-resources/napari-workshops.html":{"level":2,"children":[],"href":"/tutorials/further-resources/napari-workshops.html","text":"napari workshops"},"/tutorials/applications/dask.html":{"level":2,"children":[],"href":"/tutorials/applications/dask.html","text":"Using Dask and napari to process & view large datasets"},"/tutorials/applications/annotate_points.html":{"level":2,"children":[],"href":"/tutorials/applications/annotate_points.html","text":"Annotating videos with napari"},"/tutorials/tracking/index.html":{"level":2,"children":[],"href":"/tutorials/tracking/index.html","text":"Tracking"},"/tutorials/segmentation/index.html":{"level":2,"children":[],"href":"/tutorials/segmentation/index.html","text":"Segmentation"},"/tutorials/start_index.html":{"level":1,"children":["/tutorials/fundamentals/installation.html","/tutorials/fundamentals/getting_started.html","/plugins/stable/find-and-install-plugin.html","/tutorials/fundamentals/viewer.html","/tutorials/fundamentals/image.html","/tutorials/fundamentals/labels.html","/tutorials/fundamentals/points.html","/tutorials/fundamentals/shapes.html","/tutorials/fundamentals/surface.html","/tutorials/fundamentals/tracks.html","/tutorials/fundamentals/vectors.html"],"href":"/tutorials/start_index.html","text":"Getting Started"},"/tutorials/fundamentals/vectors.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/vectors.html","text":"vectors layer tutorial"},"/tutorials/fundamentals/tracks.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/tracks.html","text":"tracks layer tutorial"},"/tutorials/fundamentals/surface.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/surface.html","text":"surface layer tutorial"},"/tutorials/fundamentals/shapes.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/shapes.html","text":"shapes layer tutorial"},"/tutorials/fundamentals/points.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/points.html","text":"points layer tutorial"},"/tutorials/fundamentals/labels.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/labels.html","text":"labels layer tutorial"},"/tutorials/fundamentals/image.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/image.html","text":"image layer tutorial"},"/tutorials/fundamentals/viewer.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/viewer.html","text":"napari viewer tutorial"},"/tutorials/fundamentals/getting_started.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/getting_started.html","text":"Getting started with napari"},"/tutorials/fundamentals/installation.html":{"level":2,"children":[],"href":"/tutorials/fundamentals/installation.html","text":"How to install napari on your machine"}},"rootGlobalHeaders":["/tutorials/start_index.html","/tutorials/index.html","/howtos/index.html","/guides/stable/index.html","/plugins/stable/index.html","/community/index.html","/api/stable/index.html","/developers/index.html","/glossary.html","/release/index.html","/roadmaps/index.html","https://github.com/napari/napari","https://napari-hub.org"],"pageTitle":"Using Dask and napari to process & view large datasets","pageFrontMatter":{},"previewImage":"../../_images/dask_repr.png","previewDescription":"Often in microscopy, multidimensional data is acquired and written to disk in many small files,\neach of which contain a subset of one or more dimensions from the complete dataset.\nFor example, in a...","appScripts":[{"src":"/_static/documentation_options.js"},{"src":"/_static/jquery.js"},{"src":"/_static/underscore.js"},{"src":"/_static/doctools.js"},{"src":"/_static/togglebutton.js"},{"src":"/_static/clipboard.min.js"},{"src":"/_static/copybutton.js"},{"children":"var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';"},{"src":"https://unpkg.com/thebe@0.5.1/lib/index.js"},{"children":"\n        const thebe_selector = \".thebe\"\n        const thebe_selector_input = \"pre\"\n        const thebe_selector_output = \".output\"\n    "},{"src":"/_static/sphinx-thebe.js"}],"appStyleSheets":[{"href":"/_static/pygments.css","rel":"stylesheet"},{"href":"/_static/togglebutton.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/copybutton.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/mystnb.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/sphinx-thebe.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css","rel":"stylesheet","type":"text/css"},{"href":"/_static/panels-variables.06eb56fa6e07937060861dad626602ad.css","rel":"stylesheet","type":"text/css"}],"pageBodyHtml":"\n        <div id=\"documentation_options\" data-url_root=\"../../\"></div>\n        <div class=\"section\" id=\"using-dask-and-napari-to-process-view-large-datasets\">\n\n<p>Often in microscopy, multidimensional data is acquired and written to disk in many small files,\neach of which contain a subset of one or more dimensions from the complete dataset.\nFor example, in a 5-dimensional experiment\n(e.g. 3D z-stacks acquired for multiple channels at various moments over time),\neach file on disk might be a 3D TIFF stack from a single channel at a single timepoint.\nData may also be stored in some proprietary format.\nAs the size of the dataset grows,\nviewing arbitrary slices (in time, channel, z) of these datasets can become cumbersome.</p>\n<p>Chunked file formats exist (such as <a class=\"reference external\" href=\"https://support.hdfgroup.org/HDF5/\" target=\"_blank\" rel=\"noreferrer\">hdf5</a> and <a class=\"reference external\" href=\"https://zarr.readthedocs.io/en/stable/\" target=\"_blank\" rel=\"noreferrer\">zarr</a>) that store data in a way that makes it easier to retrieve arbitrary subsets of the dataset, but they require either data duplication, or “committing” to a new file standard.</p>\n<blockquote>\n<div><p><strong>Note</strong>: This tutorial is not meant to promote a folder of TIFFs as a “good way” to store large datasets on disk;\nbut it is undoubtedly a common scenario in microscopy.\nChunked formats such as <code class=\"docutils literal notranslate\"><span class=\"pre\">hdf5</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">zarr</span></code> are superior in many ways,\nbut they do require the user to either duplicate their data\nor go “all in” and delete the original data after conversion.\nAnd while <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> can easily handle something like a <code class=\"docutils literal notranslate\"><span class=\"pre\">zarr</span></code> store,\nit can be a bit more limiting inasmuch as it requires programs that are capable of viewing it (i.e. you can’t necessarily just drag it into Fiji …)</p>\n</div></blockquote>\n<p>The first part of this tutorial demonstrates how to use <a class=\"reference external\" href=\"https://docs.dask.org/en/latest/\" target=\"_blank\" rel=\"noreferrer\"><code class=\"docutils literal notranslate\"><span class=\"pre\">Dask</span></code></a>\nand <a class=\"reference external\" href=\"https://docs.dask.org/en/latest/delayed.html\" target=\"_blank\" rel=\"noreferrer\"><code class=\"docutils literal notranslate\"><span class=\"pre\">dask.delayed</span></code></a>\n(or <a class=\"reference external\" href=\"https://github.com/dask/dask-image\" target=\"_blank\" rel=\"noreferrer\"><code class=\"docutils literal notranslate\"><span class=\"pre\">dask_image</span></code></a>) to feed <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> image data “<a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Lazy_evaluation\" target=\"_blank\" rel=\"noreferrer\">lazily</a>”:\nthat is, the specific image file corresponding to the requested timepoint/channel\nis only read from disk at the moment it is required\n(based on the current position of the dimension sliders in <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code>).\nAdditionally, we will see that <em>any</em> function that takes a filepath\nand returns a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array can be used to lazily read image data.\nThis can be useful if you have a proprietary format that is not immediately recognized by <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code>\n(but for which you have at least some way of reading into a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array)</p>\n<p>In some cases, data must be further processed prior to viewing,\nsuch as a deskewing step for images acquired on a stage-scanning light sheet microscope.\nOr perhaps you’d like to apply some basic image corrections or ratiometry prior to viewing.\nThe second part of this tutorial demonstrates the use of the <a class=\"reference external\" href=\"https://docs.dask.org/en/latest/array-api.html#dask.array.map_blocks\" target=\"_blank\" rel=\"noreferrer\"><code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.map_blocks</span></code></a> function\nto describe an arbitrary sequence of functions in a declarative manner\nthat will be performed <em>on demand</em> as you explore the data (i.e. move the sliders) in <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code>.</p>\n<div class=\"section\" id=\"using-dask-delayed-to-load-images\">\n<h2>Using <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.delayed</span></code> to load images<a class=\"headerlink\" href=\"#using-dask-delayed-to-load-images\" title=\"Permalink to this headline\">¶</a></h2>\n<p>If you have a function that can take a filename and return a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array,\nsuch as <code class=\"docutils literal notranslate\"><span class=\"pre\">skimage.io.imread</span></code>,\nyou can create a “lazy” version of that function by calling <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.delayed</span></code> on the function itself.\nThis <em>new</em> function, when handed a filename,\nwill not actually read the file until explicitly asked with the <code class=\"docutils literal notranslate\"><span class=\"pre\">compute()</span></code> method:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">skimage.io</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask</span> <span class=\"kn\">import</span> <span class=\"n\">delayed</span>\n\n<span class=\"n\">lazy_imread</span> <span class=\"o\">=</span> <span class=\"n\">delayed</span><span class=\"p\">(</span><span class=\"n\">imread</span><span class=\"p\">)</span>\n<span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">lazy_imread</span><span class=\"p\">(</span><span class=\"s1\">'/path/to/file.tif'</span><span class=\"p\">)</span>  <span class=\"c1\"># doesn't actually read the file</span>\n<span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>  <span class=\"c1\"># *now* it reads.</span>\n</pre></div>\n</div>\n<p>(If you have an unusual image format,\nbut you <em>do</em> have a python function that returns a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array,\nsimply substitute it for <code class=\"docutils literal notranslate\"><span class=\"pre\">skimage.io.imread</span></code> in the example above).</p>\n<p>We can create a <a class=\"reference external\" href=\"https://docs.dask.org/en/latest/array.html\" target=\"_blank\" rel=\"noreferrer\">Dask array</a> of delayed file-readers\nfor <em>all</em> of the files in our multidimensional experiment using the <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.from_delayed</span></code> function\nand a <a class=\"reference external\" href=\"https://docs.python.org/3/library/glob.html\" target=\"_blank\" rel=\"noreferrer\"><code class=\"docutils literal notranslate\"><span class=\"pre\">glob</span></code></a> filename pattern\n(<em>this example assumes that all files are of the same <code class=\"docutils literal notranslate\"><span class=\"pre\">shape</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">dtype</span></code>!</em>):</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">skimage.io</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n<span class=\"kn\">from</span> <span class=\"nn\">skimage.io.collection</span> <span class=\"kn\">import</span> <span class=\"n\">alphanumeric_key</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask</span> <span class=\"kn\">import</span> <span class=\"n\">delayed</span>\n<span class=\"kn\">import</span> <span class=\"nn\">dask.array</span> <span class=\"k\">as</span> <span class=\"nn\">da</span>\n<span class=\"kn\">from</span> <span class=\"nn\">glob</span> <span class=\"kn\">import</span> <span class=\"n\">glob</span>\n\n<span class=\"n\">filenames</span> <span class=\"o\">=</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">glob</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/experiment/*.tif\"</span><span class=\"p\">),</span> <span class=\"n\">key</span><span class=\"o\">=</span><span class=\"n\">alphanumeric_key</span><span class=\"p\">)</span>\n<span class=\"c1\"># read the first file to get the shape and dtype</span>\n<span class=\"c1\"># ASSUMES THAT ALL FILES SHARE THE SAME SHAPE/TYPE</span>\n<span class=\"n\">sample</span> <span class=\"o\">=</span> <span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"n\">filenames</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n\n<span class=\"n\">lazy_imread</span> <span class=\"o\">=</span> <span class=\"n\">delayed</span><span class=\"p\">(</span><span class=\"n\">imread</span><span class=\"p\">)</span>  <span class=\"c1\"># lazy reader</span>\n<span class=\"n\">lazy_arrays</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">lazy_imread</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">fn</span> <span class=\"ow\">in</span> <span class=\"n\">filenames</span><span class=\"p\">]</span>\n<span class=\"n\">dask_arrays</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">from_delayed</span><span class=\"p\">(</span><span class=\"n\">delayed_reader</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">sample</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">sample</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">delayed_reader</span> <span class=\"ow\">in</span> <span class=\"n\">lazy_arrays</span>\n<span class=\"p\">]</span>\n<span class=\"c1\"># Stack into one large dask.array</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"p\">(</span><span class=\"n\">dask_arrays</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># (nfiles, nz, ny, nx)</span>\n\n<span class=\"c1\"># in jupyter notebook the repr of a dask stack provides a useful visual:</span>\n<span class=\"n\">stack</span>\n</pre></div>\n</div>\n<p><img alt=\"image: dask array html representation\" src=\"../../_images/dask_repr.png\"></p>\n<p><em>No data has been read from disk yet!</em></p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> is capable of consuming Dask arrays,\nso you can simply call <code class=\"docutils literal notranslate\"><span class=\"pre\">napari.view_image</span></code> on this <code class=\"docutils literal notranslate\"><span class=\"pre\">stack</span></code> and behind the scenes,\nDask will take care of reading the data from disk\nand handing a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array to <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> each time a new timepoint or channel is requested.</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">napari</span>\n\n<span class=\"c1\"># specify contrast_limits and multiscale=False with big data</span>\n<span class=\"c1\"># to avoid unnecessary computations</span>\n<span class=\"n\">napari</span><span class=\"o\">.</span><span class=\"n\">view_image</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">,</span> <span class=\"n\">contrast_limits</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2000</span><span class=\"p\">],</span> <span class=\"n\">multiscale</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p><em>Note: providing the</em> <code class=\"docutils literal notranslate\"><span class=\"pre\">contrast_limits</span></code> <em>and</em> <code class=\"docutils literal notranslate\"><span class=\"pre\">multiscale</span></code> <em>arguments prevents</em> <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> <em>from trying to calculate the data min/max, which can take an extremely long time with big data.\nSee <a class=\"reference external\" href=\"https://github.com/napari/napari/issues/736\" target=\"_blank\" rel=\"noreferrer\">napari issue #736</a> for further discussion.</em></p>\n</div>\n<div class=\"section\" id=\"make-your-life-easier-with-dask-image\">\n<h2>Make your life easier with <code class=\"docutils literal notranslate\"><span class=\"pre\">dask-image</span></code><a class=\"headerlink\" href=\"#make-your-life-easier-with-dask-image\" title=\"Permalink to this headline\">¶</a></h2>\n<p>This pattern for creating a <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array</span></code> from image data\nhas been previously described in an <a class=\"reference external\" href=\"https://blog.dask.org/2019/06/20/load-image-data\" target=\"_blank\" rel=\"noreferrer\">excellent blog post</a> by John Kirkham.\nIt is a common-enough pattern that John created a useful library (<a class=\"reference external\" href=\"https://github.com/dask/dask-image\" target=\"_blank\" rel=\"noreferrer\"><code class=\"docutils literal notranslate\"><span class=\"pre\">dask-image</span></code></a>)\nthat does all this for you,\nprovided your image format can be read by the <a class=\"reference external\" href=\"https://github.com/soft-matter/pims\" target=\"_blank\" rel=\"noreferrer\"><code class=\"docutils literal notranslate\"><span class=\"pre\">pims</span></code></a> (Python Image Sequence) reader\n(if not, see note above about providing your own reader function with <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.delayed</span></code>).</p>\n<p>Using <code class=\"docutils literal notranslate\"><span class=\"pre\">dask-image</span></code>, <em>all</em> of the above code can be simplified to 5 lines:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">napari</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask_image.imread</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/experiment/*.tif\"</span><span class=\"p\">)</span>\n<span class=\"n\">napari</span><span class=\"o\">.</span><span class=\"n\">view_image</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">,</span> <span class=\"n\">contrast_limits</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2000</span><span class=\"p\">],</span> <span class=\"n\">multiscale</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p><img alt=\"image: mCherry-H2B showing chromosome separation during mitosis. Collected on a lattice light sheet microscope\" src=\"../../_images/dask1.gif\"></p>\n<div class=\"section\" id=\"side-note-regarding-higher-dimensional-datasets\">\n<h3><strong>Side note regarding higher-dimensional datasets</strong><a class=\"headerlink\" href=\"#side-note-regarding-higher-dimensional-datasets\" title=\"Permalink to this headline\">¶</a></h3>\n<p>In the above example, it would be quite common to have a 5+ dimensional dataset\n(e.g. different timepoints <em>and</em> channels represented among the 3D TIFF files in a folder).\nA standard approach to deal with that sort of thing in <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> would be to <code class=\"docutils literal notranslate\"><span class=\"pre\">reshape</span></code> the array after instantiation.\nWith Dask, reshaping arrays can <em>sometimes</em> lead to unexpected read events if you’re not careful.</p>\n<p>For example:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dask_image.imread</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">'/path/to/experiment/*.tif'</span><span class=\"p\">)</span>\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># -&gt; something like (1200, 64, 256, 280)</span>\n<span class=\"n\">stack</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>  <span class=\"c1\"># incurs a single file read</span>\n\n<span class=\"c1\"># if there were two channels in that folder you might try to do this:</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">600</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">280</span><span class=\"p\">)</span>\n<span class=\"c1\"># but now trying to read just the first timepoint in the first channel:</span>\n<span class=\"n\">stack</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>  <span class=\"c1\"># incurs 600 read events!</span>\n</pre></div>\n</div>\n<p>We will update this post as best-practices emerge,\nbut one possible solution to this is to avoid reshaping\nDask arrays altogether, by constructing multiple Dask arrays using <code class=\"docutils literal notranslate\"><span class=\"pre\">dask-image</span></code>, and then using\n<code class=\"docutils literal notranslate\"><span class=\"pre\">da.stack</span></code> to combine them:</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">dask_image.imread</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n<span class=\"kn\">import</span> <span class=\"nn\">dask.array</span> <span class=\"k\">as</span> <span class=\"nn\">da</span>\n\n<span class=\"c1\"># # instead of this</span>\n<span class=\"c1\"># stack = imread('/path/to/experiment/*.tif')</span>\n<span class=\"c1\"># stack = stack.reshape(2, 600, 64, 256, 280)</span>\n<span class=\"c1\"># stack[0, 0].compute()  # incurs 600 read events!</span>\n\n<span class=\"c1\"># do something like this:</span>\n<span class=\"n\">file_pattern</span> <span class=\"o\">=</span> <span class=\"s2\">\"/path/to/experiment/*ch</span><span class=\"si\">{}</span><span class=\"s2\">*.tif\"</span>\n<span class=\"n\">channels</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"n\">file_pattern</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">nchannels</span><span class=\"p\">)]</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"p\">(</span><span class=\"n\">channels</span><span class=\"p\">)</span>\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># (2, 600, 64, 256, 280)</span>\n<span class=\"n\">stack</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">compute</span><span class=\"p\">()</span>  <span class=\"c1\"># incurs a single file read</span>\n\n</pre></div>\n</div>\n</div>\n</div>\n<div class=\"section\" id=\"processing-data-with-dask-array-map-blocks\">\n<h2>Processing data with <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.map_blocks</span></code><a class=\"headerlink\" href=\"#processing-data-with-dask-array-map-blocks\" title=\"Permalink to this headline\">¶</a></h2>\n<p>As previously mentioned,\nsometimes it is desirable to process data prior to viewing.\nWe’ll take as an example\na series of TIFF files acquired on a lattice-light-sheet microscope.\nA typical workflow might be to deskew, deconvolve, and perhaps crop\nor apply some channel registration prior to viewing.</p>\n<p>With <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.map_blocks</span></code> we can apply any function that accepts a <code class=\"docutils literal notranslate\"><span class=\"pre\">numpy</span></code> array\nand returns a modified array to all the images in our <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array</span></code>.\nIt will be evaluated lazily, when requested (in this case, by <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code>);\nwe do not have to wait for it to process the entire dataset.</p>\n<p>Here is an example of a script that will take a folder of raw tiff files,\nand lazily read, deskew, deconvolve, crop,\nand display them, <em>on demand</em> as you move the <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> dimensions sliders around.</p>\n<div class=\"highlight-python notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">napari</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pycudadecon</span>\n<span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"kn\">import</span> <span class=\"n\">partial</span>\n<span class=\"kn\">from</span> <span class=\"nn\">skimage</span> <span class=\"kn\">import</span> <span class=\"n\">io</span>\n<span class=\"kn\">from</span> <span class=\"nn\">dask_image.imread</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n\n<span class=\"c1\"># load stacks with dask_image, and psf with skimage</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/experiment/*.tif\"</span><span class=\"p\">)</span>\n<span class=\"n\">psf</span> <span class=\"o\">=</span> <span class=\"n\">io</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/psf.tif\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># prepare some functions that accept a numpy array</span>\n<span class=\"c1\"># and return a processed array</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">last3dims</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">):</span>\n    <span class=\"c1\"># this is just a wrapper because the pycudadecon function</span>\n    <span class=\"c1\"># expects ndims==3 but our blocks will have ndim==4</span>\n    <span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"n\">func</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">crop</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">):</span>\n    <span class=\"c1\"># simple cropping function</span>\n    <span class=\"k\">return</span> <span class=\"n\">array</span><span class=\"p\">[:,</span> <span class=\"mi\">2</span><span class=\"p\">:,</span> <span class=\"mi\">10</span><span class=\"p\">:</span><span class=\"o\">-</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"p\">:</span><span class=\"mi\">500</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># https://docs.python.org/3.8/library/functools.html#functools.partial</span>\n<span class=\"n\">deskew</span> <span class=\"o\">=</span> <span class=\"n\">last3dims</span><span class=\"p\">(</span><span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">pycudadecon</span><span class=\"o\">.</span><span class=\"n\">deskew_gpu</span><span class=\"p\">,</span> <span class=\"n\">angle</span><span class=\"o\">=</span><span class=\"mf\">31.5</span><span class=\"p\">))</span>\n<span class=\"n\">deconv</span> <span class=\"o\">=</span> <span class=\"n\">last3dims</span><span class=\"p\">(</span><span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">pycudadecon</span><span class=\"o\">.</span><span class=\"n\">decon</span><span class=\"p\">,</span> <span class=\"n\">psf</span><span class=\"o\">=</span><span class=\"n\">psf</span><span class=\"p\">,</span> <span class=\"n\">background</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"c1\"># note: this is done in two steps just as an example...</span>\n<span class=\"c1\"># in reality pycudadecon.decon also has a deskew argument</span>\n\n<span class=\"c1\"># map and chain those functions across all dask blocks</span>\n<span class=\"n\">deskewed</span> <span class=\"o\">=</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">map_blocks</span><span class=\"p\">(</span><span class=\"n\">deskew</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s2\">\"uint16\"</span><span class=\"p\">)</span>\n<span class=\"n\">deconvolved</span> <span class=\"o\">=</span> <span class=\"n\">deskewed</span><span class=\"o\">.</span><span class=\"n\">map_blocks</span><span class=\"p\">(</span><span class=\"n\">deconv</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s2\">\"float32\"</span><span class=\"p\">)</span>\n<span class=\"n\">cropped</span> <span class=\"o\">=</span> <span class=\"n\">deconvolved</span><span class=\"o\">.</span><span class=\"n\">map_blocks</span><span class=\"p\">(</span><span class=\"n\">crop</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s2\">\"float32\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># put the resulting dask array into napari.</span>\n<span class=\"c1\"># (don't forget the contrast limits and multiscale==False !)</span>\n<span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">napari</span><span class=\"o\">.</span><span class=\"n\">view_image</span><span class=\"p\">(</span>\n    <span class=\"n\">cropped</span><span class=\"p\">,</span>\n    <span class=\"n\">contrast_limits</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">1500</span><span class=\"p\">],</span>\n    <span class=\"n\">multiscale</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span>\n    <span class=\"n\">ndisplay</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span>\n    <span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">napari</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre></div>\n</div>\n<p>Of course, the GUI isn’t as responsive as it would be if you had processed the data up front\nand loaded the results into RAM and viewed them in <code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> (it’s doing a lot of work after all!),\nbut it’s surprisingly usable,\nand allows you to preview the result of a relatively complex processing pipeline <em>on-the-fly</em>,\nfor arbitrary timepoints/channels, while storing <em>only</em> the raw data on disk.</p>\n<p><img alt=\"image: same dataset, demonstrating on-the-fly read → deskew → deconvolve → crop\" src=\"../../_images/dask2.gif\"></p>\n<p>This workflow is very much patterned after <a class=\"reference external\" href=\"https://blog.dask.org/2019/08/09/image-itk\" target=\"_blank\" rel=\"noreferrer\">another great post by John Kirkham, Matthew Rocklin, and Matthew McCormick</a>\nthat describes a similar image processing pipeline using <a class=\"reference external\" href=\"https://itk.org/\" target=\"_blank\" rel=\"noreferrer\">ITK</a>.\n<code class=\"docutils literal notranslate\"><span class=\"pre\">napari</span></code> simply sits at the end of this lazy processing chain,\nready to show you the result on demand!</p>\n</div>\n<div class=\"section\" id=\"further-reading\">\n<h2>Further reading<a class=\"headerlink\" href=\"#further-reading\" title=\"Permalink to this headline\">¶</a></h2>\n<ul class=\"simple\">\n<li><p><a class=\"reference external\" href=\"https://docs.dask.org/en/latest/delayed.html\" target=\"_blank\" rel=\"noreferrer\">Documentation on dask.delayed</a></p></li>\n<li><p><a class=\"reference external\" href=\"https://blog.dask.org/2019/06/20/load-image-data\" target=\"_blank\" rel=\"noreferrer\">Dask working notes on dask-image</a></p></li>\n<li><p><a class=\"reference external\" href=\"https://blog.dask.org/2019/08/09/image-itk\" target=\"_blank\" rel=\"noreferrer\">Dask working notes on image processing with <code class=\"docutils literal notranslate\"><span class=\"pre\">dask.array.map_blocks</span></code></a></p></li>\n</ul>\n</div>\n</div>\n\n    <script type=\"text/x-thebe-config\">\n    {\n        requestKernel: true,\n        binderOptions: {\n            repo: \"binder-examples/jupyter-stacks-datascience\",\n            ref: \"master\",\n        },\n        codeMirrorConfig: {\n            theme: \"abcdef\",\n            mode: \"python\"\n        },\n        kernelOptions: {\n            kernelName: \"python3\",\n            path: \"./tutorials/applications\"\n        },\n        predefinedOutput: true\n    }\n    </script>\n    <script>kernelName = 'python3'</script>\n      ","pageHeaders":[{"href":"#using-dask-delayed-to-load-images","text":"Using dask.delayed to load images"},{"href":"#make-your-life-easier-with-dask-image","text":"Make your life easier with dask-image"},{"href":"#processing-data-with-dask-array-map-blocks","text":"Processing data with dask.array.map_blocks"},{"href":"#further-reading","text":"Further reading"}],"ipynbSource":"","mdSource":"/_sources/tutorials/applications/dask.md"}},"__N_SSG":true}